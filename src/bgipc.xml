<?xml version='1.0' encoding="utf-8"?>
<!-- Copyright (C) 2010 Brian "Beej Jorgensen" Hall <beej@beej.us> -->

<!DOCTYPE guide SYSTEM "bg.dtd" [

<!ENTITY copydates "2015">

<!ENTITY samplepre "http://beej.us/guide/bgipc/examples/">
<!ENTITY homepage "http://beej.us/guide/bgipc/">
<!ENTITY bgneturl "http://beej.us/guide/bgnet/">

<!ENTITY redir "http://beej.us/guide/url/">

<!ENTITY beejmail "beej@beej.us">

<!ENTITY cclicenseurl "http://creativecommons.org/licenses/by-nc-nd/3.0/">

<!ENTITY manpre "http://www.linuxmanpages.com/man">
<!-- "2/accept.2", for instance -->
<!ENTITY manpost ".php">

<!ENTITY pmanpre "http://www.opengroup.org/onlinepubs/007908775/xsh/">
<!-- "ioctl", for instance -->
<!ENTITY pmanpost ".html">

<!ENTITY esrsmartqs "http://www.catb.org/~esr/faqs/smart-questions.html">
<!ENTITY lolonais "http://beej.us/pirates/pirate_view.php?file=lolonais.jpg">
<!ENTITY wpconcur "http://en.wikipedia.org/wiki/Concurrency_&#x25;28computer_science&#x25;29"> <!-- &#x25 == '%' -->
<!ENTITY davesysurl "http://www.cs.cf.ac.uk/Dave/C/">
<!ENTITY linuxkernelipc "http://tldp.org/LDP/tlk/ipc/ipc.html">
<!ENTITY lpgipc "http://tldp.org/LDP/lpg/node7.html">
<!ENTITY unpurl "http://www.kohala.com/start/unpv22e/unpv22e.html">

<!ENTITY emdash "&#x2014;">
<!ENTITY Eacute "&#xC9;">
]>

<guide id="index">

<guideinfo>
<title>Beej's Guide to Unix IPC</title>

<author>
	<name>Brian "Beej Jorgensen" Hall</name>
	<email>&beejmail;</email>
</author>

<!--
History:
0.9.3 (14-May-1997)
1.0.0 (13-May-2007, yes, really)
1.0.1 (25-Jul-2007, remove unnecessary casts, gets in kirk and spock)
1.0.2 (25-Jul-2008, fix fcntl stuff)
1.1.0 (19-Jul-2010, new signals section)
1.1.1 (19-Jul-2010, sa_handler should have been sa_flags)
1.1.2 (15-Dec-2010, fix msgbuf size calculation, rvdw@tarma.com)
1.1.3 (01-Dec-2015, really fix msgp size calcuation for msgsnd/rcv)
-->

<version>Version 1.1.3</version>
<date>December 1, 2015</date>

<copyright>Copyright <copysym/> &copydates;  Brian "Beej Jorgensen" Hall</copyright>

	<legal><p>Unless otherwise mutually agreed by the parties in
writing, the author offers the work as-is and makes no representations or
warranties of any kind concerning the work, express, implied, statutory
or otherwise, including, without limitation, warranties of title,
merchantibility, fitness for a particular purpose, noninfringement, or
the absence of latent or other defects, accuracy, or the presence of
absence of errors, whether or not discoverable.</p>

<p>Except to the extent required by applicable law, in no event will
the author be liable to you on any legal theory for any special,
incidental, consequential, punitive or exemplary damages arising out of
the use of the work, even if the author has been advised
of the possibility of such damages.</p>

<p>This document is freely distributable under the terms of the Creative
Commons Attribution-Noncommercial-No Derivative Works 3.0 License. See
the Copyright and Distribution section for details.</p></legal>

	<comment><p>This guide is written in XML using the vim editor on a
Slackware Linux box loaded with GNU tools.  The cover "art" and diagrams
are produced with Inkscape.  The XML is converted into HTML and XSL-FO
by custom Python scripts. The XSL-FO output is then munged by Apache FOP
to produce PDF documents, using Liberation fonts.  The toolchain is
composed of 100% Free and Open Source Software.</p></comment>

</guideinfo>

<!--
<indexinfo id="zindex">
<indexentry id="AF_INET"><const>AF_INET</const></indexentry>
<indexentry id="disconnected network" see="private network">disconnected network</indexentry>
</indexinfo>
-->

<!-- ======================================================= -->
<!-- Introduction -->
<!-- ======================================================= -->

<sect1 id="intro">
<title>Intro</title>

<p>You know what's easy?  <func>fork()</func> is easy.  You can fork off
new processes all day and have them deal with individual chunks of a
problem in parallel.  Of course, its easiest if the processes don't have
to communicate with one another while they're running and can just sit
there doing their own thing.</p>

<p>However, when you start <func>fork()</func>'ing processes, you
immediately start to think of the neat multi-user things you could do if
the processes could talk to each other easily.  So you try making a
global array and then <func>fork()</func>'ing to see if it is shared.
(That is, see if both the child and parent process use the same array.)
Soon, of course, you find that the child process has its own copy of the
array and the parent is oblivious to whatever changes the child makes to
it.</p>

<p>How do you get these guys to talk to one another, share data
structures, and be generally amicable?  This document discusses several
methods of <emp>Interprocess Communication</emp> (IPC) that can
accomplish this, some of which are better suited to certain tasks than
others.</p>

<!-- ======================================================= -->
<!-- Audience -->
<!-- ======================================================= -->
<sect2 id="audience">
<title>Audience</title>

<p>If you know C or C++ and are pretty good using a Unix environment (or
other POSIXey environment that supports these system calls) these
documents are for you.  If you aren't that good, well, don't sweat
it&emdash;you'll be able to figure it out.  I make the assumption,
however, that you have a fair smattering of C programming
experience.</p>

<p>As with <ulink url="&bgneturl;">Beej's Guide to Network Programming
Using Internet Sockets</ulink>, these documents are meant to springboard
the aforementioned user into the realm of IPC by delivering a concise
overview of various IPC techniques.  This is not the definitive set of
documents that cover this subject, by any means.  Like I said, it is
designed to simply give you a foothold in this, the exciting world of
IPC.</p>

</sect2>

<!-- ======================================================= -->
<!-- Platform and Compiler -->
<!-- ======================================================= -->
<sect2 id="platform">
<title>Platform and Compiler</title>

<p>The examples in this document were compiled under Linux using
<com>gcc</com>.  They should compile anywhere a good Unix compiler is
available.</p>

</sect2>

<!-- ======================================================= -->
<!-- Homepage -->
<!-- ======================================================= -->
<sect2 id="homepage">
<title>Official Homepage</title>

<p>This official location of this document is
<tt><ulink url="&homepage;" footnote="n">&homepage;</ulink></tt>.</p>

</sect2>

<!-- ======================================================= -->
<!-- Email policy -->
<!-- ======================================================= -->
<sect2 id="emailpolicy">
<title>Email Policy</title>

<p>I'm generally available to help out with <!--<ii key="email to
Beej"/>-->email questions so feel free to write in, but I can't guarantee a
response.  I lead a pretty busy life and there are times when I just
can't answer a question you have.  When that's the case, I usually just
delete the message.  It's nothing personal; I just won't ever have the
time to give the detailed answer you require.</p>

<p>As a rule, the more complex the question, the less likely I am to
respond.  If you can narrow down your question before mailing it and be
sure to include any pertinent information (like platform, compiler,
error messages you're getting, and anything else you think might help me
troubleshoot), you're much more likely to get a response.  For more
pointers, read ESR's document, <ulink url="&esrsmartqs;">How To Ask
Questions The Smart Way</ulink>.</p>

<p>If you don't get a response, hack on it some more, try to find the
answer, and if it's still elusive, then write me again with the
information you've found and hopefully it will be enough for me to help
out.</p>

<p>Now that I've badgered you about how to write and not write me, I'd
just like to let you know that I <emp>fully</emp> appreciate all the
praise the guide has received over the years.  It's a real morale boost,
and it gladdens me to hear that it is being used for good! <smiley/>
Thank you!</p>

</sect2>

<!-- ======================================================= -->
<!-- Mirroring -->
<!-- ======================================================= -->

<sect2 id="mirroring">
<title>Mirroring</title>

<p><!--<ii key="mirroring"/>-->You are more than welcome to mirror this site,
whether publicly or
privately.  If you publicly mirror the site and want me to link to it
from the main page, drop me a line at <email>&beejmail;</email>.</p>

</sect2>

<!-- ======================================================= -->
<!-- Translators -->
<!-- ======================================================= -->

<sect2 id="xlate">
<title>Note for Translators</title>

<p><!--<ii key="translations"/>-->If you want to translate the guide into
another language, write me at <email>&beejmail;</email> and I'll link to
your translation from the main page. Feel free to add your name and
contact info to the translation.</p>

<p>Please note the license restrictions in the Copyright and
Distribution section, below.</p>

<p>Sorry, but due to space constraints, I cannot host the
translations myself.</p>

</sect2>

<!-- ======================================================= -->
<!-- Copyright -->
<!-- ======================================================= -->
<sect2 id="copyright">
<title>Copyright and Distribution</title>

<p>Beej's Guide to Network Programming is Copyright <copysym/> &copydates;
Brian "Beej Jorgensen" Hall.</p>

<p>With specific exceptions for source code and translations, below,
this work is licensed under the Creative Commons Attribution-
Noncommercial- No Derivative Works 3.0 License. To view a copy of this
license, visit <tt><ulink url="&cclicenseurl;"
footnote="n">&cclicenseurl;</ulink></tt> or send a letter to Creative
Commons, 171 Second Street, Suite 300, San Francisco, California, 94105,
USA.</p>

<p>One specific exception to the "No Derivative Works" portion of the
license is as follows: this guide may be freely translated into any
language, provided the translation is accurate, and the guide is
reprinted in its entirety.  The same license restrictions apply to the
translation as to the original guide.  The translation may also include
the name and contact information for the translator.</p>

<p>The C source code presented in this document is hereby granted to the
public domain, and is completely free of any license restriction.</p>

<p>Educators are freely encouraged to recommend or supply copies of this
guide to their students.</p>

<p>Contact <email>&beejmail;</email> for more information.</p>

</sect2>

</sect1> <!-- /Introduction -->

<!-- ======================================================= -->
<!-- Fork -->
<!-- ======================================================= -->

<sect1 id="fork">
<title>A <func>fork()</func> Primer</title>

<p>"Fork", aside from being one of those words that begins to appear
very strange after you've typed it repeatedly, refers to the way Unix
creates new processes.  This document gives a quick and dirty
<func>fork()</func> primer, since use of that system call will pop up in
other IPC documents.  If you already know all about <func>fork()</func>,
you might as well skip this document.</p>

<!-- ======================================================= -->
<!-- "Seek ye the Gorge of Eternal Peril" -->
<!-- ======================================================= -->

<sect2 id="forkperil">
<title>"Seek ye the Gorge of Eternal Peril"</title>

<p><func>fork()</func> can be thought of as a ticket to power.  Power
can sometimes be thought of as a ticket to destruction.  Therefore, you
should be careful while messing with <func>fork()</func> on your system,
especially while people are cranking their nearly-late semester projects
and are ready to nuke the first organism that brings the system to a
halt.  It's not that you should never play with <func>fork()</func>, you
just have to be cautious.  It's kind of like sword-swallowing; if you're
careful, you won't disembowel yourself.</p>

<p>Since you're still here, I suppose I'd better deliver the goods.
Like I said, <func>fork()</func> is how Unix starts new processes.
Basically, how it works is this: the parent process (the one that
already exists) <func>fork()</func>'s a child process (the new one).
The child process gets a <emp>copy</emp> of the parent's data.
<foreign>Voila!</foreign> You have two processes where there was only
one!</p>

<p>Of course, there are all kinds of gotchas you must deal with when
<func>fork()</func>ing processes or else your sysadmin will get irate with
you when you fill of the system process table and they have to punch the
reset button on the machine.</p>

<p>First of all, you should know something of process behavior under
Unix.  When a process dies, it doesn't really go away completely.  It's
dead, so it's no longer running, but a small remnant is waiting around
for the parent process to pick up.  This remnant contains the return
value from the child process and some other goop.  So after a parent
process <func>fork()</func>s a child process, it must
<func>wait()</func> (or <func>waitpid()</func>) for that child process
to exit.  It is this act of <func>wait()</func>ing that allows all
remnants of the child to vanish.</p>

<p>Naturally, there is an exception to the above rule: the parent can
ignore the <const>SIGCHLD</const> signal (<const>SIGCLD</const> on some
older systems) and then it won't have to <func>wait()</func>.  This can
be done (on systems that support it) like this:</p>

<code> main()
{
	signal(SIGCHLD, SIG_IGN);  /* now I don't have to wait()! */
	.
	.
	fork();fork();fork();  /* Rabbits, rabbits, rabbits! */</code>

<p>Now, when a child process dies and has not been <func>wait()</func>ed
on, it will usually show up in a <com>ps</com> listing as
"<tt>&lt;defunct&gt;</tt>".  It will remain this way until the parent
<func>wait()</func>s on it, or it is dealt with as mentioned below.</p>

<p>Now there is another rule you must learn: when the parent dies before
it <func>wait()</func>s for the child (assuming it is not ignoring
<const>SIGCHLD</const>), the child is reparented to the <com>init</com>
process (PID 1).  This is not a problem if the child is still living
well and under control.  However, if the child is already defunct, we're
in a bit of a bind.  See, the original parent can no longer
<func>wait()</func>, since it's dead.  So how does <com>init</com> know
to <func>wait()</func> for these <emp>zombie processes</emp>?</p>

<p>The answer: it's magic!  Well, on some systems, <com>init</com>
periodically destroys all the defunct processes it owns.  On other
systems, it outright refuses to become the parent of any defunct
processes, instead destroying them immediately.  If you're using one of
the former systems, you could easily write a loop that fills up the
process table with defunct processes owned by <com>init</com>.  Wouldn't
that make your sysadmin happy?</p>

<p>Your mission: make sure your parent process either ignores
<const>SIGHCLD</const>, or <func>wait()</func>s for all the children it
<func>fork()</func>s.  Well, you don't <emp>always</emp> have to do that
(like if you're starting a daemon or something), but you code with
caution if you're a <func>fork()</func> novice.  Otherwise, feel free to
blast off into the stratosphere.</p>

<p>To summerize: children become defunct until the parent
<func>wait()</func>s, unless the parent is ignoring
<const>SIGCHLD</const>.  Furthermore, children (living or defunct) whose
parents die without <func>wait()</func>ing for them (again assuming the
parent is not ignoring <const>SIGCHLD</const>) become children of the
<com>init</com> process, which deals with them heavy-handedly.</p>

</sect2>

<!-- ======================================================= -->
<!-- "I'm mentally prepared!  Give me The Button!" -->
<!-- ======================================================= -->

<sect2 id="forkbutton">
<title>"I'm mentally prepared!  Give me <emp>The Button</emp>!"</title>

<p>Right!  Here's an <ulink url="&samplepre;fork1.c">example</ulink> of
how to use <func>fork()</func>:</p>

<code><![CDATA[#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/wait.h>

int main(void)
{
	pid_t pid;
	int rv;

	switch(pid = fork()) {
	case -1:
		perror("fork");  /* something went wrong */
		exit(1);		 /* parent exits */

	case 0:
		printf(" CHILD: This is the child process!\n");
		printf(" CHILD: My PID is %d\n", getpid());
		printf(" CHILD: My parent's PID is %d\n", getppid());
		printf(" CHILD: Enter my exit status (make it small): ");
		scanf(" %d", &rv);
		printf(" CHILD: I'm outta here!\n");
		exit(rv);

	default:
		printf("PARENT: This is the parent process!\n");
		printf("PARENT: My PID is %d\n", getpid());
		printf("PARENT: My child's PID is %d\n", pid);
		printf("PARENT: I'm now waiting for my child to exit()...\n");
		wait(&rv);
		printf("PARENT: My child's exit status is: %d\n", WEXITSTATUS(rv));
		printf("PARENT: I'm outta here!\n");
	}

	return 0;
}]]></code>

<p>There is a ton of stuff to note from this example, so we'll just
start from the top, shall we?</p>

<p><var>pid_t</var> is the generic process type.  Under Unix, this is a
<type>short</type>.  So, I call <func>fork()</func> and save the return
value in the <var>pid</var> variable.  <func>fork()</func> is easy,
since it can only return three things:</p>

<table border="0" width="85%">
<tr><td width="15%"><p><const>0</const></p></td>
<td width="85%"><p>If it returns <const>0</const>, you are the child
process.  You can get the parent's PID by calling
<func>getppid()</func>.  Of course, you can get your own PID by calling
<func>getpid()</func>.</p></td></tr>

<tr><td><p><const>-1</const>:</p></td>
<td><p>If it returns <const>-1</const>, something went wrong, and no
child was created.  Use <func>perror()</func> to see what happened.
You've probably filled the process table&emdash;if you turn around
you'll see your sysadmin coming at you with a fireaxe.</p></td></tr>

<tr><td><p>else:</p></td>
<td><p>Any other value returned by <func>fork()</func> means that you're
the parent and the value returned is the PID of your child.  This is the
only way to get the PID of your child, since there is no
<func>getcpid()</func> call (obviously due to the one-to-many
relationship between parents and children.)</p></td></tr>

</table>

<p>When the child finally calls <func>exit()</func>, the return value
passed will arrive at the parent when it <func>wait()</func>s.  As you
can see from the <func>wait()</func> call, there's some weirdness coming
into play when we print the return value.  What's this
<const>WEXITSTATUS()</const> stuff, anyway?  Well, that is a macro that
extracts the child's actual return value from the value
<func>wait()</func> returns.  Yes, there is more information buried in
that <type>int</type>.  I'll let you look it up on your own.</p>

<p>"How," you ask, "does <func>wait()</func> know which process to wait
for?  I mean, since the parent can have multiple children, which one
does <func>wait()</func> actually wait for?"  The answer is simple, my
friends: it waits for whichever one happens to exit first.  If you must,
you can specify exactly which child to wait for by calling
<func>waitpid()</func> with your child's PID as an argument.</p>

<p>Another interesting thing to note from the above example is that both
parent and child use the <var>rv</var> variable.  Does this mean that it
is shared between the processes?  <emp>NO!</emp>  If it was, I wouldn't
have written all this IPC stuff.  <emp>Each process has its own copy of
all variables.</emp>  There is a lot of other stuff that is copied, too,
but you'll have to read the <com>man</com> page to see what.</p>

<p>A final note about the above program: I used a switch statement to
handle the <func>fork()</func>, and that's not exactly typical.  Most
often you'll see an <statement>if</statement> statement there; sometimes
it's as short as:</p>

<code>if (!fork()) {
        printf("I'm the child!\n");
        exit(0);
    } else {
        printf("I'm the parent!\n");
        wait(NULL);
    }</code>

<p>Oh yeah&emdash;the above example also demonstrates how to
<func>wait()</func> if you don't care what the return value of the child
is: you just call it with <const>NULL</const> as the argument.</p>

</sect2>

<!-- ======================================================= -->
<!-- Fork summary -->
<!-- ======================================================= -->

<sect2 id="forksum">
<title>Summary</title>

<p>Now you know all about the mighty <func>fork()</func> function!  It's
more useful that a wet bag of worms in most computationally intensive
situations, and you can amaze your friends at parties.  Additionally, it
can help make you more attractive to members of the opposite sex, unless
you're male.</p>

</sect2>

</sect1> <!-- fork -->

<!-- ======================================================= -->
<!-- Signals -->
<!-- ======================================================= -->

<sect1 id="signals">
<title>Signals</title>

<p>There is a sometimes useful method for one process to bug another:
signals.  Basically, one process can "raise" a signal and have it
delivered to another process.  The destination process's signal handler
(just a function) is invoked and the process can handle it.</p>

<p>The devil's in the details, of course, and in actuality what you are
permitted to do safely inside your signal hander is rather limited.
Nevertheless, signals provide a useful service.</p>

<p>For example, one process might want to stop another one, and this
can be done by sending the signal <const>SIGSTOP</const> to that
process.  To continue, the process has to receive signal
<const>SIGCONT</const>.  How does the process know to do this when it
receives a certain signal?  Well, many signals are predefined and the
process has a default signal handler to deal with it.</p>

<p>A default handler?  Yes.  Take <const>SIGINT</const> for example.
This is the interrupt signal that a process receives when the user hits
<tt>^C</tt>.  The default signal handler for <const>SIGINT</const>
causes the process to exit!  Sound familiar?  Well, as you can imagine,
you can override the <const>SIGINT</const> to do whatever you want (or
nothing at all!)  You could have your process <func>printf()</func>
"Interrupt?!  No way, Jose!" and go about its merry business.</p>

<p>So now you know that you can have your process respond to just about
any signal in just about any way you want.  Naturally, there are
exceptions because otherwise it would be too easy to understand.  Take
the ever popular <const>SIGKILL</const>, signal #9.  Have you ever typed
<nobr>"<com>kill -9 <emp>nnnn</emp></com>"</nobr> to kill a runaway
process?  You were sending it <const>SIGKILL</const>.  Now you might
also remember that no process can get out of a <nobr>"<com>kill
-9</com>",</nobr> and you would be correct.  <const>SIGKILL</const> is
one of the signals you <com>can't</com> add your own signal handler for.
The aforementioned <const>SIGSTOP</const> is also in this category.</p>

<p>(Aside: you often use the Unix "<com>kill</com>" command without
specifying a signal to send...so what signal is it?  The answer:
<const>SIGTERM</const>.  You can write your own handler for
<const>SIGTERM</const> so your process won't respond to a regular
"<com>kill</com>", and the user must then use "<com>kill -9</com>" to
destroy the process.)</p>

<p>Are all the signals predefined?  What if you want to send a signal
that has significance that only you understand to a process?  There are
two signals that aren't reserved: <const>SIGUSR1</const> and
<const>SIGUSR2</const>.  You are free to use these for whatever you
want and handle them in whatever way you choose.  (For example, my cd
player program might respond to <const>SIGUSR1</const> by advancing to
the next track.  In this way, I could control it from the command line
by typing <nobr>"<com>kill -SIGUSR1 <var>nnnn</var></com>".)</nobr></p>


<sect2 id="catchsig">
<title>Catching Signals for Fun and Profit!</title>

<p>As you can guess the Unix "kill" command is one way to send signals
to a process.  By sheer unbelievable coincidence, there is a system call
called <func>kill()</func> which does the same thing.  It takes for its
argument a signal number (as defined in <file>signal.h</file>) and a
process ID.  Also, there is a library routine called
<func>raise()</func> which can be used to raise a signal within the same
process.</p>

<p>The burning question remains: how do you catch a speeding
<const>SIGTERM</const>?  You need to call <func>sigaction()</func> and
tell it all the gritty details about which signal you want to catch and
which function you want to call to handle it.</p>

<p>Here's the <func>sigaction()</func> breakdown:</p>

<code>int sigaction(int <param>sig</param>, const struct sigaction *<param>act</param>,
              struct sigaction *<param>oact</param>);</code>

<p>The first parameter, <param>sig</param> is which signal to catch.
This can be (probably "should" be) a symbolic name from
<file>signal.h</file> along the lines of <const>SIGINT</const>.  That's
the easy bit.</p>

<p>The next field, <param>act</param> is a pointer to a <type>struct
sigaction</type> which has a bunch of fields that you can fill in to
control the behavior of the signal handler.  (A pointer to the signal
handler function itself included in the <type>struct</type>.)</p>

<p>Lastly <param>oact</param> can be <const>NULL</const>, but if not, it
returns the <emp>old</emp> signal handler information that was in place
before. This is useful if you want to restore the previous signal
handler at a later time.</p>

<p>We'll focus on these three fields in the <type>struct
sigaction</type>:</p>

<table border="0" width="80%">
<tr><td width="25%"><th>Signal</th></td><td width="70%"><th>Description</th></td></tr>
<tr><td><type>sa_handler</type></td><td>The signal handler function (or <const>SIG_IGN</const> to ignore the signal)</td></tr>
<tr><td><type>sa_mask</type></td><td>A set of signals to block while this one is being handled</td></tr>
<tr><td><type>sa_flags</type></td><td>Flags to modify the behavior of the handler, or <const>0</const></td></tr>
</table>

<p>What about that <type>sa_mask</type> field?  When you're handling a
signal, you might want to block other signals from being delivered, and
you can do this by adding them to the <type>sa_mask</type>
It's a "set", which means you can do normal set operations to manipulate
them: <func>sigemptyset()</func>, <func>sigfillset()</func>,
<func>sigaddset()</func>, <func>sigdelset()</func>, and
<func>sigismember()</func>.  In this example, we'll just clear the set
and not block any other signals.</p>

<p>Examples always help!  Here's one that handled <const>SIGINT</const>,
which can be delivered by hitting <tt>^C</tt>, called <file><ulink
url="&samplepre;sigint.c">sigint.c</ulink></file>:</p>

<code><![CDATA[#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <errno.h>
#include <signal.h>

void sigint_handler(int sig)
{
        /* using a char[] so that sizeof will work */
	const char msg[] = "Ahhh! SIGINT!\n";
	write(0, msg, sizeof(msg));
}

int main(void)
{
	char s[200];
        struct sigaction sa = {
            .sa_handler = sigint_handler,
            .sa_flags = 0, // or SA_RESTART
            .sa_mask = 0,
        };

	if (sigaction(SIGINT, &sa, NULL) == -1) {
		perror("sigaction");
		exit(1);
	}

	printf("Enter a string:\n");

	if (fgets(s, sizeof s, stdin) == NULL)
		perror("fgets");
	else 
		printf("You entered: %s\n", s);

	return 0;
}]]></code>

<p>This program has two functions: <func>main()</func> which sets up the
signal handler (using the <func>sigaction()</func> call), and
<func>sigint_handler()</func> which is the signal handler, itself.</p>

<p>What happens when you run it?  If you are in the midst of entering a
string and you hit <tt>^C</tt>, the call to <func>gets()</func> fails
and sets the global variable <var>errno</var> to <const>EINTR</const>.
Additionally, <func>sigint_handler()</func> is called and does its
routine, so you actually see:</p>

<screen>Enter a string:
<b>the quick brown fox jum^C</b>Ahhh! SIGINT!
fgets: Interrupted system call</screen>

<p>And then it exits.  Hey&emdash;what kind of handler is this, if it
just exits anyway?</p>

<p>Well, we have a couple things at play, here. First, you'll notice
that the signal handler was called, because it printed "Ahhh! SIGINT!"
But then <func>fgets()</func> returns an error, namely
<const>EINTR</const>, or "Interrupted system call".  See, some system
calls can be interrupted by signals, and when this happens, they return
an error.  You might see code like this (sometimes cited as an excusable
use of <tt>goto</tt>):</p>

<code><![CDATA[
restart:
	if (some_system_call() == -1) {
		if (errno == EINTR) goto restart;
		perror("some_system_call");
		exit(1);
	}]]></code>

<p>Instead of using <tt>goto</tt> like that, you might be able to set
your <type>sa_flags</type> to include <const>SA_RESTART</const>.  For
example, if we change our <const>SIGINT</const> handler code to look
like this:</p>

<code>	sa.sa_flags = SA_RESTART;</code>

<p>Then our run looks more like this:</p>

<screen>Enter a string:
<b>Hello^C</b>Ahhh! SIGINT!
<b>Er, hello!^C</b>Ahhh! SIGINT!
<b>This time fer sure!</b>
You entered: This time fer sure!</screen>

<p>Some system calls are interruptible, and some can be restarted.  It's
system dependent.</p>

</sect2>

<sect2 id="handlerok">
<title>The Handler is not Omnipotent</title>

<p>You have to be careful when you make function calls in your signal
handler. Those functions must be "async safe", so they can be called
without invoking undefined behavior.</p>

<p>You might be curious, for instance, why my signal handler, above,
called <func>write()</func> to output the message instead of
<func>printf()</func>. Well, the answer is that POSIX says that
<func>write()</func> is async-safe (so is safe to call from within the
handler), while <func>printf()</func> is not.</p>

<p>The library functions and system calls that are async-safe and can be
called from within your signal handlers are (breath):</p>

<p><func>_Exit()</func>, <func>_exit()</func>, <func>abort()</func>,
<func>accept()</func>, <func>access()</func>, <func>aio_error()</func>,
<func>aio_return()</func>, <func>aio_suspend()</func>,
<func>alarm()</func>, <func>bind()</func>, <func>cfgetispeed()</func>,
<func>cfgetospeed()</func>, <func>cfsetispeed()</func>,
<func>cfsetospeed()</func>, <func>chdir()</func>, <func>chmod()</func>,
<func>chown()</func>, <func>clock_gettime()</func>,
<func>close()</func>, <func>connect()</func>, <func>creat()</func>,
<func>dup()</func>, <func>dup2()</func>, <func>execle()</func>,
<func>execve()</func>, <func>fchmod()</func>, <func>fchown()</func>,
<func>fcntl()</func>, <func>fdatasync()</func>, <func>fork()</func>,
<func>fpathconf()</func>, <func>fstat()</func>, <func>fsync()</func>,
<func>ftruncate()</func>, <func>getegid()</func>,
<func>geteuid()</func>, <func>getgid()</func>, <func>getgroups()</func>,
<func>getpeername()</func>, <func>getpgrp()</func>,
<func>getpid()</func>, <func>getppid()</func>,
<func>getsockname()</func>, <func>getsockopt()</func>,
<func>getuid()</func>, <func>kill()</func>, <func>link()</func>,
<func>listen()</func>, <func>lseek()</func>, <func>lstat()</func>,
<func>mkdir()</func>, <func>mkfifo()</func>, <func>open()</func>,
<func>pathconf()</func>, <func>pause()</func>, <func>pipe()</func>,
<func>poll()</func>, <func>posix_trace_event()</func>,
<func>pselect()</func>, <func>raise()</func>, <func>read()</func>,
<func>readlink()</func>, <func>recv()</func>, <func>recvfrom()</func>,
<func>recvmsg()</func>, <func>rename()</func>, <func>rmdir()</func>,
<func>select()</func>, <func>sem_post()</func>, <func>send()</func>,
<func>sendmsg()</func>, <func>sendto()</func>, <func>setgid()</func>,
<func>setpgid()</func>, <func>setsid()</func>,
<func>setsockopt()</func>, <func>setuid()</func>,
<func>shutdown()</func>, <func>sigaction()</func>,
<func>sigaddset()</func>, <func>sigdelset()</func>,
<func>sigemptyset()</func>, <func>sigfillset()</func>,
<func>sigismember()</func>, <func>sleep()</func>, <func>signal()</func>,
<func>sigpause()</func>, <func>sigpending()</func>,
<func>sigprocmask()</func>, <func>sigqueue()</func>,
<func>sigset()</func>, <func>sigsuspend()</func>,
<func>sockatmark()</func>, <func>socket()</func>,
<func>socketpair()</func>, <func>stat()</func>, <func>symlink()</func>,
<func>sysconf()</func>, <func>tcdrain()</func>, <func>tcflow()</func>,
<func>tcflush()</func>, <func>tcgetattr()</func>,
<func>tcgetpgrp()</func>, <func>tcsendbreak()</func>,
<func>tcsetattr()</func>, <func>tcsetpgrp()</func>, <func>time()</func>,
<func>timer_getoverrun()</func>, <func>timer_gettime()</func>,
<func>timer_settime()</func>, <func>times()</func>,
<func>umask()</func>, <func>uname()</func>, <func>unlink()</func>,
<func>utime()</func>, <func>wait()</func>, <func>waitpid()</func>, and
<func>write()</func>.</p>

<p>Of course, you can call your own functions from within your signal
handler (as long they don't call any non-async-safe functions.)</p>

<p>But wait&emdash;there's more!</p>

<p>You also cannot safely alter any shared (e.g. global) data, with one
notable exception: variables that are declared to be of storage class
and type <type>volatile sig_atomic_t</type>.</p>

<p>Here's an example that handles <const>SIGUSR1</const> by setting a
global flag, which is then examined in the main loop to see if the
handler was called.  This is <file><ulink
url="&samplepre;sigusr.c">sigusr.c</ulink></file>:</p>

<code><![CDATA[#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <errno.h>
#include <signal.h>

volatile sig_atomic_t got_usr1;

void sigusr1_handler(int sig)
{
	got_usr1 = 1;
}

int main(void)
{
        struct sigaction sa = {
            .sa_handler = sigusr1_handler,
            .sa_flags = 0, // or SA_RESTART
            .sa_mask = 0,
        };

	got_usr1 = 0;

	if (sigaction(SIGUSR1, &sa, NULL) == -1) {
		perror("sigaction");
		exit(1);
	}

	while (!got_usr1) {
		printf("PID %d: working hard...\n", getpid());
		sleep(1);
	}

	printf("Done in by SIGUSR1!\n");

	return 0;
}]]></code>

<p>Fire it it up in one window, and then use the <com>kill -USR1</com> in
another window to kill it.  The <file>sigusr</file> program
conveniently prints out its process ID so you can pass it to
<com>kill</com>:</p>

<screen>$ <b>sigusr</b>
PID 5023: working hard...
PID 5023: working hard...
PID 5023: working hard...</screen>

<p>Then in the other window, send it the signal
<const>SIGUSR1</const>:</p>

<screen>$ <b>kill -USR1 5023</b></screen>

<p>And the program should respond:</p>

<screen>PID 5023: working hard...
PID 5023: working hard...
Done in by SIGUSR1!</screen>

<p>(And the response should be immediate even if <func>sleep()</func>
has just been called&emdash;<func>sleep()</func> gets interrupted by
signals.)</p>

</sect2> 


<sect2 id="signalwrong">
<title>What about <func>signal()</func></title>

<p>ANSI-C defines a function called <func>signal()</func> that can be used to
catch signals.  It's not as reliable or as full-featured as
<func>sigaction()</func>, so use of <func>signal()</func>is generally
discouraged.</p>

</sect2>


<sect2 id="signalpop">
<title>Some signals to make you popular</title>

<p>Here is a list of signals you (most likely) have at your
disposal:</p>

<table border="0" width="80%">
<tr><td width="30%"><th>Signal</th></td><td width="70%"><th>Description</th></td></tr>
<tr><td>SIGABRT</td><td>Process abort signal.</td></tr>
<tr><td>SIGALRM</td><td>Alarm clock.</td></tr>
<tr><td>SIGFPE</td><td>Erroneous arithmetic operation.</td></tr>
<tr><td>SIGHUP</td><td>Hangup.</td></tr>
<tr><td>SIGILL</td><td>Illegal instruction.</td></tr>
<tr><td>SIGINT</td><td>Terminal interrupt signal.</td></tr>
<tr><td>SIGKILL</td><td>Kill (cannot be caught or ignored).</td></tr>
<tr><td>SIGPIPE</td><td>Write on a pipe with no one to read it.</td></tr>
<tr><td>SIGQUIT</td><td>Terminal quit signal.</td></tr>
<tr><td>SIGSEGV</td><td>Invalid memory reference.</td></tr>
<tr><td>SIGTERM</td><td>Termination signal.</td></tr>
<tr><td>SIGUSR1</td><td>User-defined signal 1.</td></tr>
<tr><td>SIGUSR2</td><td>User-defined signal 2.</td></tr>
<tr><td>SIGCHLD</td><td>Child process terminated or stopped.</td></tr>
<tr><td>SIGCONT</td><td>Continue executing, if stopped.</td></tr>
<tr><td>SIGSTOP</td><td>Stop executing (cannot be caught or ignored).</td></tr>
<tr><td>SIGTSTP</td><td>Terminal stop signal.</td></tr>
<tr><td>SIGTTIN</td><td>Background process attempting read.</td></tr>
<tr><td>SIGTTOU</td><td>Background process attempting write.</td></tr>
<tr><td>SIGBUS</td><td>Bus error.</td></tr>
<tr><td>SIGPOLL</td><td>Pollable event.</td></tr>
<tr><td>SIGPROF</td><td>Profiling timer expired.</td></tr>
<tr><td>SIGSYS</td><td>Bad system call.</td></tr>
<tr><td>SIGTRAP</td><td>Trace/breakpoint trap.</td></tr>
<tr><td>SIGURG</td><td>High bandwidth data is available at a socket.</td></tr>
<tr><td>SIGVTALRM</td><td>Virtual timer expired.</td></tr>
<tr><td>SIGXCPU</td><td>CPU time limit exceeded.</td></tr>
<tr><td>SIGXFSZ</td><td>File size limit exceeded.</td></tr>
</table>

<p>Each signal has its own default signal handler, the behavior of which
is defined in your local man pages.</p>

</sect2>


<sect2 id="siggloss">
<title>What I have Glossed Over</title>

<p>Nearly all of it.  There are tons of flags, realtime signals, mixing
signals with threads, masking signals, <func>longjmp()</func> and
signals, and more.</p>

<p>Of course, this is just a "getting started" guide, but in a last-ditch
effort to give you more information, here is a list of man pages with more
information:</p>

<p>Handling signals:
<ulink url="&pmanpre;sigaction&pmanpost;"><func>sigaction()</func></ulink>
<ulink url="&pmanpre;sigwait&pmanpost;"><func>sigwait()</func></ulink>
<ulink url="&pmanpre;sigwaitinfo&pmanpost;"><func>sigwaitinfo()</func></ulink>
<ulink url="&pmanpre;sigtimedwait&pmanpost;"><func>sigtimedwait()</func></ulink>
<ulink url="&pmanpre;sigsuspend&pmanpost;"><func>sigsuspend()</func></ulink>
<ulink url="&pmanpre;sigpending&pmanpost;"><func>sigpending()</func></ulink></p>

<p>Delivering signals:
<ulink url="&pmanpre;kill&pmanpost;"><func>kill()</func></ulink>
<ulink url="&pmanpre;raise&pmanpost;"><func>raise()</func></ulink>
<ulink url="&pmanpre;sigqueue&pmanpost;"><func>sigqueue()</func></ulink></p>

<p>Set operations:
<ulink url="&pmanpre;sigemptyset&pmanpost;"><func>sigemptyset()</func></ulink>
<ulink url="&pmanpre;sigfillset&pmanpost;"><func>sigfillset()</func></ulink>
<ulink url="&pmanpre;sigaddset&pmanpost;"><func>sigaddset()</func></ulink>
<ulink url="&pmanpre;sigdelset&pmanpost;"><func>sigdelset()</func></ulink>
<ulink url="&pmanpre;sigismember&pmanpost;"><func>sigismember()</func></ulink></p>

<p>Other:
<ulink url="&pmanpre;sigprocmask&pmanpost;"><func>sigprocmask()</func></ulink>
<ulink url="&pmanpre;sigaltstack&pmanpost;"><func>sigaltstack()</func></ulink>
<ulink url="&pmanpre;siginterrupt&pmanpost;"><func>siginterrupt()</func></ulink>
<ulink url="&pmanpre;sigsetjmp&pmanpost;"><func>sigsetjmp()</func></ulink>
<ulink url="&pmanpre;siglongjmp&pmanpost;"><func>siglongjmp()</func></ulink>
<ulink url="&pmanpre;signal&pmanpost;"><func>signal()</func></ulink></p>

</sect2>

</sect1> <!-- signals -->

<!-- ======================================================= -->
<!-- Pipes -->
<!-- ======================================================= -->

<sect1 id="pipes">
<title>Pipes</title>

<p>There is no form of IPC that is simpler than pipes.  Implemented on
every flavor of Unix, <func>pipe()</func> and <func><link
dest="fork">fork()</link></func> make up the functionality behind the
"<com>|</com>" in <nobr>"<com>ls | more</com>".</nobr>  They are
marginally useful for cool things, but are a good way to learn about
basic methods of IPC.</p>

<p>Since they're so very very easy, I shant spent much time on them.
We'll just have some examples and stuff.</p>

<sect2 id="pipesclean">
<title>"These pipes are clean!"</title>

<p>Wait!  Not so fast.  I might need to define a "file descriptor" at
this point.  Let me put it this way: you know about "<type>FILE*</type>"
from <file>stdio.h</file>, right?  You know how you have all those nice
functions like <func>fopen()</func>, <func>fclose()</func>,
<func>fwrite()</func>, and so on?  Well, those  are actually high level
functions that are implemented using <emp>file descriptors</emp>, which
use system calls such as <func>open()</func>, <func>creat()</func>,
<func>close()</func>, and <func>write()</func>.  File descriptors are
simply <type>ints</type> that are analogous to <type>FILE*</type>'s in
<file>stdio.h</file>.</p>

<p>For example, <var>stdin</var> is file descriptor "0",
<var>stdout</var> is "1", and <var>stderr</var> is "2".  Likewise, any
files you open using <func>fopen()</func> get their own file descriptor,
although this detail is hidden from you.  (This file descriptor can be
retrived from the <type>FILE*</type> by using the <func>fileno()</func>
macro from <file>stdio.h</file>.)</p>

<figure>
<image file="pipe1-96-4.149.png" printfile="pipe1-300-4.149.png" printwidth="4.149in" alt="[pipe diagram 1]"/>
<title>How a pipe is organized.</title>
</figure>

<p>Basically, a call to the <func>pipe()</func> function returns a pair
of file descriptors.  One of these descriptors is connected to the write
end of the pipe, and the other is connected to the read end.  Anything
can be written to the pipe, and read from the other end in the order it
came in.  On many systems, pipes will fill up after you write about 10K
to them without reading anything out.</p>

<p>As a <ulink url="&samplepre;pipe1.c">useless example</ulink>, the
following program creates, writes to, and reads from a pipe.</p>

<code><![CDATA[#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <unistd.h>

int main(void)
{
	int pfds[2];
	char buf[30];

	if (pipe(pfds) == -1) {
		perror("pipe");
		exit(1);
	}

	printf("writing to file descriptor #%d\n", pfds[1]);
	write(pfds[1], "test", 5);
	printf("reading from file descriptor #%d\n", pfds[0]);
	read(pfds[0], buf, 5);
	printf("read \"%s\"\n", buf);

	return 0;
}]]></code>

<p>As you can see, <func>pipe()</func> takes an array of two
<type>int</type>s as an argument.  Assuming no errors, it connects two
file descriptors and returns them in the array.  The first element of
the array is the reading-end of the pipe, the second is the writing
end.</p>

</sect2>

<sect2 id="pipefork">

<title><func>fork()</func> and <func>pipe()</func>&emdash;you have the
power!</title>

<p>From the above example, it's pretty hard to see how these would even
be useful.  Well, since this is an IPC document, let's put a
<func>fork()</func> in the mix and see what happens.  Pretend that you
are a top federal agent assigned to get a child process to send the word
"test" to the parent.  Not very glamorous, but no one ever said computer
science would be the X-Files, Mulder.</p>

<p>First, we'll have the parent make a pipe.  Secondly, we'll
<func>fork()</func>.  Now, the <func>fork()</func> man page tells us
that the child will receive a copy of all the parent's file descriptors,
and this includes a copy of the pipe's file descriptors.
<foreign>Alors</foreign>, the child will be able to send stuff to the
write-end of the pipe, and the parent will get it off the read-end.
<ulink url="&samplepre;pipe2.c">Like this</ulink>:</p>

<code><![CDATA[#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <sys/types.h>
#include <unistd.h>

int main(void)
{
	int pfds[2];
	char buf[30];

	pipe(pfds);

	if (!fork()) {
		printf(" CHILD: writing to the pipe\n");
		write(pfds[1], "test", 5);
		printf(" CHILD: exiting\n");
		exit(0);
	} else {
		printf("PARENT: reading from pipe\n");
		read(pfds[0], buf, 5);
		printf("PARENT: read \"%s\"\n", buf);
		wait(NULL);
	}

	return 0;
}]]></code>

<p>Please note, your programs should have a lot more error checking than
mine do.  I leave it out on occasion to help keep things clear.</p>

<p>Anyway, this example is just like the previous one, except now we
<func>fork()</func> of a new process and have it write to the pipe,
while the parent reads from it.  The resultant output will be something
similar to the following:</p>

<screen>PARENT: reading from pipe
 CHILD: writing to the pipe
 CHILD: exiting
PARENT: read "test"</screen>

<p>In this case, the parent tried to read from the pipe before the child
writes to it.  When this happens, the parent is said to
<emp>block</emp>, or sleep, until data arrives to be read.  It seems
that the parent tried to read, went to sleep, the child wrote and
exited, and the parent woke up and read the data.</p>

<p>Hurrah!!  You've just don't some interprocess communication!  That
was dreadfully simple, huh?  I'll bet you are still thinking that there
aren't many uses for <func>pipe()</func> and, well, you're probably
right.  The other forms of IPC are generally more useful and are often
more exotic.</p>

</sect2>

<sect2 id="pipequest">
<title>The search for Pipe as we know it</title>

<p>In an effort to make you think that pipes are actually reasonable
beasts, I'll give you an example of using <func>pipe()</func> in a more
familiar situation.  The challenge: implement "<nobr><com>ls | wc
-l</com></nobr>" in C.</p>

<p>This requires usage of a couple more functions you may never have
heard of: <func>exec()</func> and <func>dup()</func>.  The
<func>exec()</func> family of functions replaces the currently running
process with whichever one is passed to <func>exec()</func>.  This is
the function that we will use to run <com>ls</com> and <nobr><com>wc
-l</com></nobr>.  <func>dup()</func> takes an open file descriptor and
makes a clone (a duplicate) of it.  This is how we will connect the
standard output of the <com>ls</com> to the standard input of
<com>wc</com>.  See, stdout of <com>ls</com> flows into the pipe, and
the stdin of <com>wc</com> flows in from the pipe.  The pipe fits right
there in the middle!</p>

<p>Anyway, <ulink url="&samplepre;pipe3.c">here is the code</ulink>:</p>

<code><![CDATA[#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

int main(void)
{
	int pfds[2];

	pipe(pfds);

	if (!fork()) {
		close(1);       /* close normal stdout */
		dup(pfds[1]);   /* make stdout same as pfds[1] */
		close(pfds[0]); /* we don't need this */
		execlp("ls", "ls", NULL);
	} else {
		close(0);       /* close normal stdin */
		dup(pfds[0]);   /* make stdin same as pfds[0] */
		close(pfds[1]); /* we don't need this */
		execlp("wc", "wc", "-l", NULL);
	}

	return 0;
}]]></code>

<p>I'm going to make another note about the
<func>close()</func>/<func>dup()</func> combination since it's pretty
weird.  <func>close(1)</func> frees up file descriptor 1 (standard
output).  <func>dup(pfds[1])</func> makes a copy of the write-end of the
pipe in the first available file descriptor, which is "1", since we just
closed that.  In this way, anything that <com>ls</com> writes to
standard output (file descriptor 1) will instead go to
<var>pfds[1]</var> (the write end of the pipe).  The <com>wc</com>
section of code works the same way, except in reverse.</p>

</sect2>

<sect2 id="pipesum">
<title>Summary</title>

<p>There aren't many of these for such a simple topic.  In fact, there
are nearly just about none.  Probably the best use for pipes is the one
you're most accustomed to: sending the standard output of one command to
the standard input of another.  For other uses, it's pretty limiting and
there are often other IPC techniques that work better.</p>

</sect2>

</sect1> <!-- pipes -->

<!-- ======================================================= -->
<!-- FIFOs -->
<!-- ======================================================= -->

<sect1 id="fifos">
<title>FIFOs</title>

<p>A FIFO ("First In, First Out", pronounced "Fy-Foh") is sometimes
known as a <emp>named pipe</emp>.  That is, it's like a <link
dest="pipes">pipe</link>, except that it has a name!  In this case, the
name is that of a file that multiple processes can <func>open()</func>
and read and write to.</p>

<p>This latter aspect of FIFOs is designed to let them get around one of
the shortcomings of normal pipes: you can't grab one end of a normal
pipe that was created by an unrelated process.  See, if I run two
individual copies of a program, they can both call <func>pipe()</func>
all they want and still not be able to speak to one another.  (This is
because you must <func>pipe()</func>, then <func>fork()</func> to get a
child process that can communicate to the parent via the pipe.)  With
FIFOs, though, each unrelated process can simply <func>open()</func> the
pipe and transfer data through it.</p>


<sect2 id="fifonew">
<title>A New FIFO is Born</title>

<p>Since the FIFO is actually a file on disk, you have to do some
fancy-schmancy stuff to create it.  It's not that hard.  You just have
to call <func>mknod()</func> with the proper arguments.  Here is a
<func>mknod()</func> call that creates a FIFO:</p>

<code>mknod("myfifo", S_IFIFO | 0644 , 0);</code>

<p>In the above example, the FIFO file will be called
"<file>myfifo</file>".  The second argument is the creation mode, which
is used to tell <func>mknod()</func> to make a FIFO (the
<const>S_IFIFO</const> part of the OR) and sets access permissions to
that file (octal 644, or <tt>rw-r--r--</tt>) which can also be set by
ORing together macros from <file>sys/stat.h</file>.  This permission is
just like the one you'd set using the <com>chmod</com> command.
Finally, a device number is passed.  This is ignored when creating a
FIFO, so you can put anything you want in there.</p>

<p>(An aside: a FIFO can also be created from the command line using the
Unix <com>mknod</com> command.)</p>

</sect2>

<sect2 id="fifopc">
<title>Producers and Consumers</title>

<p>Once the FIFO has been created, a process can start up and open it
for reading or writing using the standard <func>open()</func> system
call.</p>

<p>Since the process is easier to understand once you get some code in
your belly, I'll present here two programs which will send data through
a FIFO.  One is <file>speak.c</file> which sends data through the FIFO,
and the other is called <file>tick.c</file>, as it sucks data out of the
FIFO.</p>

<p>Here is <file><ulink
url="&samplepre;speak.c">speak.c</ulink></file>:</p>

<code><![CDATA[#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <string.h>
#include <fcntl.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>

#define FIFO_NAME "american_maid"

int main(void)
{
	char s[300];
	int num, fd;

	mknod(FIFO_NAME, S_IFIFO | 0666, 0);

	printf("waiting for readers...\n");
	fd = open(FIFO_NAME, O_WRONLY);
	printf("got a reader--type some stuff\n");

	while (gets(s), !feof(stdin)) {
		if ((num = write(fd, s, strlen(s))) == -1)
			perror("write");
		else
			printf("speak: wrote %d bytes\n", num);
	}

	return 0;
}]]></code>

<p>What <com>speak</com> does is create the FIFO, then try to
<func>open()</func> it.  Now, what will happen is that the
<func>open()</func> call will <emp>block</emp> until some other process
opens the other end of the pipe for reading.  (There is a way around
this&emdash;see <link dest="fifondelay"><const>O_NDELAY</const></link>,
below.)  That process is <file><ulink
url="&samplepre;tick.c">tick.c</ulink></file>, shown here:</p>

<code><![CDATA[#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <string.h>
#include <fcntl.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>

#define FIFO_NAME "american_maid"

int main(void)
{
	char s[300];
	int num, fd;

	mknod(FIFO_NAME, S_IFIFO | 0666, 0);

	printf("waiting for writers...\n");
	fd = open(FIFO_NAME, O_RDONLY);
	printf("got a writer\n");

	do {
		if ((num = read(fd, s, 300)) == -1)
			perror("read");
		else {
			s[num] = '\0';
			printf("tick: read %d bytes: \"%s\"\n", num, s);
		}
	} while (num > 0);

	return 0;
}]]></code>

<p> Like <file>speak.c</file>, <com>tick</com> will block on the
<func>open()</func> if there is no one writing to the FIFO.  As soon as
someone opens the FIFO for writing, <com>tick</com> will spring to
life.</p>

<p>Try it!  Start <com>speak</com> and it will block until you start
<com>tick</com> in another window.  (Conversely, if you start
<com>tick</com>, it will block until you start <com>speak</com> in
another window.)  Type away in the <com>speak</com> window and
<com>tick</com> will suck it all up.</p>

<p>Now, break out of <com>speak</com>.  Notice what happens: the
<func>read()</func> in <com>tick</com> returns 0, signifying EOF.  In
this way, the reader can tell when all writers have closed their
connection to the FIFO.  "What?" you ask "There can be multiple writers
to the same pipe?"  Sure!  That can be very useful, you know.  Perhaps
I'll show you later in the document how this can be exploited.</p>

<p>But for now, lets finish this topic by seeing what happens when you
break out of <com>tick</com> while <com>speak</com> is running.
"Broken Pipe"!  What does this mean?  Well, what has happened is that
when all readers for a FIFO close and the writer is still open, the
writer will receiver the signal SIGPIPE the next time it tries to
<func>write()</func>.  The default signal handler for this signal prints
"Broken Pipe" and exits.  Of course, you can handle this more gracefully
by catching SIGPIPE through the <func>signal()</func> call.</p>

<p>Finally, what happens if you have multiple readers?  Well, strange
things happen.  Sometimes one of the readers get everything.  Sometimes
it alternates between readers.  Why do you want to have multiple
readers, anyway?</p>

</sect2>

<sect2 id="fifondelay">
<title><const>O_NDELAY</const>!  I'm UNSTOPPABLE!</title>

<p>Earlier, I mentioned that you could get around the blocking
<func>open()</func> call if there was no corresponding reader or writer.
The way to do this is to call <func>open()</func> with the
<const>O_NDELAY</const> flag set in the mode argument:</p>

<code>fd = open(FIFO_NAME, O_WRONLY | <b>O_NDELAY</b>);</code>

<p>This will cause <func>open()</func> to return <const>-1</const> if
there are no processes that have the file open for reading.</p>

<p>Likewise, you can open the reader process using the
<const>O_NDELAY</const> flag, but this has a different effect: all
attempts to <func>read()</func> from the pipe will simply return
<const>0</const> bytes read if there is no data in the pipe.  (That is,
the <func>read()</func> will no longer block until there is some data in
the pipe.)  Note that you can no longer tell if <func>read()</func> is
returning <const>0</const> because there is no data in the pipe, or
because the writer has exited.  This is the price of power, but my
suggestion is to try to stick with blocking whenever possible.</p>

</sect2>

<!--  since I think this is wrong, I'm removing it
<sect2 id="fifomult">
<title>Multiple Writers&emdash;How do I multiplex all these?</title>

<p>Lets say you have a pipe with one reader and one writer connected to
it.  There's no problem for the reader, since there is only one place
its data could be coming from (namely, the one writer.)  Suddenly
another writer leaps snarling from the shadows!  Without provocation, it
begins spewing random data into the pipe!  How is the poor reader going
to sort the data from the two writers?</p>

<p>Well, there are lots of ways, and they all depend on what kind of
data you are passing back and forth.  One of the simpliest ways would
occur if all the writers were sending the same amount of data every time
(lets say, 1024 bytes).  Then the reader could read 1024 bytes at a time
and be assured that it's getting a single packet (as opposed to, say 512
bytes from one writer and 512 from the other.)  Still, though, there is
no way to tell which writer sent which packet.</p>

<p>One of the best solutions to this is for each writer to use (or
prepend to) the first couple bytes of the packet for some kind of unique
identifier.  The reader can pick up this identifier and determine which
writer sent the packet.  This "id" can be thought of as a petite packet
header.</p>

<p>Allowing for a packet header gives us a lot more flexibility with what
we can send through a pipe.  For instance, you could also add a length
field that tells the reader how many bytes of data accompany the header.
A sample data structure to hold one of these packets might be:</p>

<code> typedef struct {
	short id;
	short length; 
	char data[1024]
} PACKET;</code>

<p>By transmitting a packet with structure similar to the above, you
could have an arbitrary number of writers sending packets of varying
lengths.  The reader will be able to sort it all out since it gets the
"id" of the source writer and the length of the packet.</p>

</sect2>
-->

<sect2 id="fifoconc">
<title>Concluding Notes</title>

<p>Having the name of the pipe right there on disk sure makes it easier,
doesn't it?  Unrelated processes can communicate via pipes!  (This is an
ability you will find yourself wishing for if you use normal pipes for
too long.)  Still, though, the functionality of pipes might not be quite
what you need for your applications.  <link dest="mq">Message
queues</link> might be more your speed, if your system supports
them.</p>

</sect2>

</sect1>  <!-- FIFOs -->

<!-- ======================================================= -->
<!-- File Locking -->
<!-- ======================================================= -->

<sect1 id="flocking">
<title>File Locking</title>

<p>File locking provides a very simple yet incredibly useful mechanism
for coordinating file accesses.  Before I begin to lay out the details,
let me fill you in on some file locking secrets:</p>

<p>There are two types of locking mechanisms: mandatory and advisory.
Mandatory systems will actually prevent <func>read()</func>s and
<func>write()</func>s to file.  Several Unix systems support them.
Nevertheless, I'm going to ignore them throughout this document,
preferring instead to talk solely about advisory locks.  With an
advisory lock system, processes can still read and write from a file
while it's locked.  Useless?  Not quite, since there is a way for a
process to check for the existence of a lock before a read or write.
See, it's a kind of <emp>cooperative</emp> locking system.  This is
easily sufficient for almost all cases where file locking is
necessary.</p>

<p>Since that's out of the way, whenever I refer to a lock from now on
in this document, I'm referring to advisory locks.  So there.</p>

<p>Now, let me break down the concept of a lock a little bit more.
There are two types of (advisory!) locks: read locks and write locks
(also referred to as shared locks and exclusive locks, respectively.)
The way read locks work is that they don't interfere with other read
locks.  For instance, multiple processes can have a file locked for
reading at the same.  However, when a process has an write lock on a
file, no other process can activate either a read or write lock until it
is relinquished.  One easy way to think of this is that there can be
multiple readers simultaneously, but there can only be one writer at a
time.</p>

<p>One last thing before beginning: there are many ways to lock files in
Unix systems.  System V likes <func>lockf()</func>, which, personally, I
think sucks.  Better systems support <func>flock()</func> which offers
better control over the lock, but still lacks in certain ways.  For
portability and for completeness, I'll be talking about how to lock
files using <func>fcntl()</func>.  I encourage you, though, to use one
of the higher-level <func>flock()</func>-style functions if it suits
your needs, but I want to portably demonstrate the full range of power
you have at your fingertips.  (If your System V Unix doesn't support the
POSIX-y <func>fcntl()</func>, you'll have to reconcile the following
information with your <func>lockf()</func> man page.)</p>

<sect2 id="flockset">
<title>Setting a lock</title>

<p>The <func>fcntl()</func> function does just about everything on the
planet, but we'll just use it for file locking.  Setting the lock
consists of filling out a <nobr><type>struct flock</type></nobr>
(declared in <file>fcntl.h</file>) that describes the type of lock
needed, <func>open()</func>ing the file with the matching mode, and
calling <func>fcntl()</func> with the proper arguments, <foreign>comme
&#231;a</foreign>:</p>

<code><![CDATA[struct flock fl = {
    .l_type   = F_WRLCK,  /* F_RDLCK, F_WRLCK, F_UNLCK      */
    .l_whence = SEEK_SET, /* SEEK_SET, SEEK_CUR, SEEK_END   */
    .l_start  = 0,        /* Offset from l_whence           */
    .l_len    = 0,        /* length, 0 = to EOF             */
    // .l_pid             /* PID holding lock; F_RDLCK only */
};
int fd;

fd = open("filename", O_WRONLY);

fcntl(fd, F_SETLKW, &fl);  /* F_GETLK, F_SETLK, F_SETLKW */]]></code>

<p>What just happened?  Let's start with the <nobr><type>struct
flock</type></nobr> since the fields in it are used to
<emp>describe</emp> the locking action taking place.  Here are some
field definitions:</p>

<table border="0">
<tr><td width="20%"><var>l_type</var></td>
<td width="80%">This is where you signify the type of lock you want to set.  It's
either <const>F_RDLCK</const>, <const>F_WRLCK</const>, or
<const>F_UNLCK</const> if you want to set a read lock, write lock, or
clear the lock, respectively.</td></tr>

<tr><td><var>l_whence</var></td>
<td>This field determines where the <var>l_start</var> field starts from
(it's like an offset for the offset).  It can be either
<const>SEEK_SET</const>, <const>SEEK_CUR</const>, or
<const>SEEK_END</const>, for beginning of file, current file position,
or end of file.</td></tr>

<tr><td><var>l_start</var></td>
<td>This is the starting offset in bytes of the lock, relative to
<var>l_whence</var>.</td></tr>

<tr><td><var>l_len</var></td>
<td>This is the length of the lock region in bytes (which starts from
<var>l_start</var> which is relative to <var>l_whence</var>.</td></tr>

<tr><td><var>l_pid</var></td>
<td>The process ID of the process holding the lock.  This is set by
the kernel when using the F_RDLCK command.</td></tr>

</table>

<p>In our example, we told it make a lock of type <const>F_WRLCK</const>
(a write lock), starting relative to <const>SEEK_SET</const> (the
beginning of the file), offset <const>0</const>, length <const>0</const>
(a zero value means "lock to end-of-file), with the PID set to
<func>getpid()</func>.</p>

<p>The next step is to <func>open()</func> the file, since
<func>flock()</func> needs a file descriptor of the file that's being
locked.  Note that when you open the file, you need to open it in the
same <emp>mode</emp> as you have specified in the lock, as shown in the
table, below.  If you open the file in the wrong mode for a given lock
type, <func>fcntl()</func> will return <const>-1</const> and
<var>errno</var> will be set to <const>EBADF</const>.</p>

<table border="0" width="50%">
<tr><td width="30%"><th><var>l_type</var></th></td><td width="70%"><th>mode</th></td></tr>
<tr><td><const>F_RDLCK</const></td>
<td><const>O_RDONLY</const> or <const>O_RDWR</const></td></tr>

<tr><td><const>F_WRLCK</const></td>
<td><const>O_WRONLY</const> or <const>O_RDWR</const></td></tr>

</table>
<!-- <b>Table 1.  Lock types and corresponding <tt>open()</tt>
modes.</b> -->

<p>Finally, the call to <func>fcntl()</func> actually sets, clears, or
gets the lock.  See, the second argument (the <param>cmd</param>) to
<func>fcntl()</func> tells it what to do with the data passed to it in
the <nobr><type>struct flock</type></nobr>.  The following list
summarizes what each <func>fcntl()</func> <param>cmd</param> does:</p>

<table border="0">
<tr><td width="15%"><const>F_SETLKW</const></td>
<td width="85%">This argument tells <func>fcntl()</func> to attempt to
obtain the lock requested in the <nobr><type>struct flock</type></nobr>
structure.  If the lock cannot be obtained (since someone else has it
locked already), <func>fcntl()</func> will wait (block) until the lock
has cleared, then will set it itself.  This is a very useful command.  I
use it all the time.</td></tr>

<tr><td><const>F_SETLK</const></td>
<td>This function is almost identical to <const>F_SETLKW</const>.  The
only difference is that this one will not wait if it cannot obtain a
lock.  It will return immediately with <const>-1</const>.  This function
can be used to clear a lock by setting the <var>l_type</var> field in
the <nobr><type>struct flock</type></nobr> to
<const>F_UNLCK</const>.</td></tr>

<tr><td><const>F_GETLK</const></td>
<td>If you want to only check to see if there is a lock, but don't want
to set one, you can use this command.  It looks through all the file
locks until it finds one that conflicts with the lock you specified in
the <nobr><type>struct flock</type></nobr>.  It then copies the
conflicting lock's information into the <type>struct</type> and returns
it to you.  If it can't find a conflicting lock, <func>fcntl()</func>
returns the <type>struct</type> as you passed it, except it sets the
<var>l_type</var> field to <const>F_UNLCK</const>.</td></tr>

</table>

<p>In our above example, we call <func>fcntl()</func> with
<const>F_SETLKW</const> as the argument, so it blocks until it can set
the lock, then sets it and continues.</p>

</sect2>

<sect2 id="flockclear">
<title>Clearing a lock</title>

<p>Whew!  After all the locking stuff up there, it's time for something
easy: unlocking!  Actually, this is a piece of cake in comparison.  I'll
just reuse that first example and add the code to unlock it at the
end:</p>

<code>
struct flock fl = {
    .l_type   = F_WRLCK,  /* F_RDLCK, F_WRLCK, F_UNLCK      */
    .l_whence = SEEK_SET, /* SEEK_SET, SEEK_CUR, SEEK_END   */
    .l_start  = 0,        /* Offset from l_whence           */
    .l_len    = 0,        /* length, 0 = to EOF             */
    // .l_pid             /* PID holding lock; F_RDLCK only */
};
int fd;

fd = open("filename", O_WRONLY);  /* get the file descriptor */
fcntl(fd, F_SETLKW, &amp;fl);  /* set the lock, waiting if necessary */
.
.
.
fl.l_type   = <b>F_UNLCK</b>;  /* tell it to unlock the region */
fcntl(fd, F_SETLK, &amp;fl); /* set the region to unlocked */</code>

<p>Now, I left the old locking code in there for high contrast, but you
can tell that I just changed the <var>l_type</var> field to
<const>F_UNLCK</const> (leaving the others completely unchanged!) and
called <func>fcntl()</func> with <const>F_SETLK</const> as the command.
Easy!</p>

</sect2>

<sect2 id="flockdemo">
<title>A demo program</title>

<p>Here, I will include a demo program, <file>lockdemo.c</file>, that
waits for the user to hit return, then locks its own source, waits for
another return, then unlocks it.  By running this program in two (or
more) windows, you can see how programs interact while waiting for
locks.</p>

<p>Basically, usage is this: if you run <com>lockdemo</com> with no
command line arguments, it tries to grab a write lock
(<const>F_WRLCK</const>) on its source (<file>lockdemo.c</file>).  If
you start it with any command line arguments at all, it tries to get a
read lock (<const>F_RDLCK</const>) on it.</p>

<p><ulink url="&samplepre;lockdemo.c">Here's the source</ulink>:</p>

<code><![CDATA[#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <fcntl.h>
#include <unistd.h>

int main(int argc, char *argv[])
{
        struct flock fl = {
            .l_type = F_WRLCK,
            .l_whence = SEEK_SET,
            .l_start = 0,
            .l_len = 0,
        };
	int fd;

	if (argc > 1) 
		fl.l_type = F_RDLCK;

	if ((fd = open("lockdemo.c", O_RDWR)) == -1) {
		perror("open");
		exit(1);
	}

	printf("Press <RETURN> to try to get lock: ");
	getchar();
	printf("Trying to get lock...");

	if (fcntl(fd, F_SETLKW, &fl) == -1) {
		perror("fcntl");
		exit(1);
	}

	printf("got lock\n");
	printf("Press <RETURN> to release lock: ");
	getchar();

	fl.l_type = F_UNLCK;  /* set to unlock same region */

	if (fcntl(fd, F_SETLK, &fl) == -1) {
		perror("fcntl");
		exit(1);
	}

	printf("Unlocked.\n");

	close(fd);

	return 0;
}]]></code>

<p>Compile that puppy up and start messing with it in a couple windows.
Notice that when one <com>lockdemo</com> has a read lock, other
instances of the program can get their own read locks with no problem.
It's only when a write lock is obtained that other processes can't get a
lock of any kind.</p>

<p>Another thing to notice is that you can't get a write lock if there
are any read locks on the same region of the file.  The process waiting
to get the write lock will wait until all the read locks are cleared.
One upshot of this is that you can keep piling on read locks (because a
read lock doesn't stop other processes from getting read locks) and any
processes waiting for a write lock will sit there and starve.  There
isn't a rule anywhere that keeps you from adding more read locks if
there is a process waiting for a write lock.  You must be careful.</p>

<p>Practically, though, you will probably mostly be using write locks to
guarantee exclusive access to a file for a short amount of time while
it's being updated; that is the most common use of locks as far as I've
seen.  And I've seen them all...well, I've seen one...a small one...a
picture&emdash;well, I've heard about them.</p>

</sect2>

<sect2 id="flocksum">
<title>Summary</title>

<p>Locks rule.  Sometimes, though, you might need more control over your
processes in a producer-consumer situation.  For this reason, if no
other, you should see the document on System V <link
dest="semaphores">semaphores</link> (or POSIX, for that matter; they aren't identical)
if your system supports such a
beast.  They provide a more extensive and at least equally function
equivalent to file locks.</p>

</sect2>

</sect1> <!-- File Locking -->

<!-- ======================================================= -->
<!-- Message Queues -->
<!-- ======================================================= -->

<sect1 id="mq">
<title>Message Queues</title>

<p>Those people who brought us System V have seen fit to include some
IPC goodies that have been implemented on various platforms (including
Linux, of course.)  This document describes the usage and functionality
of the extremely groovy System V Message Queues!  Linux also supports a
POSIX version of each of these; see <emp>mq_overview</emp>,
<emp>sem_overview</emp>, and <emp>shm_overview</emp> in the man
pages.</p>

<p>As usual, I want to spew some overview at you before getting into the
nitty-gritty.  A message queue works kind of like a <link
dest="fifos">FIFO</link>, but supports some additional functionality.
Generally, see, messages are taken off the queue in the order they are
put on.  Specifically, however, there are ways to pull certain messages
out of the queue before they reach the front.  It's like cutting in
line.  (Incidentally, don't try to cut in line while visiting the Great
America amusement park in Silicon Valley, as you can be arrested for it.
They take cutting <emp>very</emp> seriously down there.)</p>

<p>In terms of usage, a process can create a new message queue, or it can
connect to an existing one.  In this, the latter, way two processes can
exchange information through the same message queue.  Score.</p>

<p>One more thing about System V IPC: when you create a message queue,
it doesn't go away until you destroy it, just like how files don't
go away until you explicitly remove them.  All the processes that
have ever used it can quit, but the queue will still exist.  A good practice
is to use the <com>ipcs</com> command to check if any of your unused
message queues are just floating around out there.  You can destroy them
with the <com>ipcrm</com> command, which is preferable to getting a
visit from the sysadmin telling you that you've grabbed every available
message queue on the system.</p>


<sect2 id="mqwhere">
<title>Where's my queue?</title>

<p>Let's get something going!  First of all, you want to connect to a
queue, or create it if it doesn't exist.  The call to accomplish this is
the <func>msgget()</func> system call:</p>

<code>int msgget(key_t <param>key</param>, int <param>msgflg</param>);</code>

<p><func>msgget()</func> returns the message queue ID on success, or
<const>-1</const> on failure (and it sets <var>errno</var>, of
course.)</p>

<p>The arguments are a little weird, but can be understood with a little
brow-beating.  The first, <param>key</param> is a system-wide unique
identifier describing the queue you want to connect to (or create).
Every other process that wants to connect to this queue will have to use
the same <param>key</param>.</p>

<p>The other argument, <param>msgflg</param> tells <func>msgget()</func>
what to do with queue in question.  To create a queue, this field must
be set equal to <const>IPC_CREAT</const> bit-wise OR'd with the
permissions for this queue.  (The queue permissions are the same as
standard file permissions&emdash;queues take on the user-id and group-id
of the program that created them.)</p>

<p>A sample call is given in the following section.</p>

</sect2>

<sect2 id="mqftok">
<title>"Are you the Key Master?"</title>

<p>What about this <param>key</param> nonsense?  How do we create one?
Well, since the type <type>key_t</type> is actually just a
<type>long</type>, you can use any number you want.  But what if you
hard-code the number and some other unrelated program hardcodes the same
number but wants another queue?  The solution is to use the
<func>ftok()</func> function which generates a key from two
arguments:</p>

<code>key_t ftok(const char *<param>path</param>, int <param>id</param>);</code>

<p>Ok, this is getting weird.  Basically, <param>path</param> just has
to be a path to a file that uniquely identifies this application; the
pathname to the application's configuration file is a common string
to use (what are the odds that two applications will use the same
configuration file?).  The other argument,
<param>id</param> is usually just set to some arbitrary char, like 'A'.
The <func>ftok()</func> function uses information about the named file
(like inode number, etc.) and the <param>id</param> to generate a
probably-unique <param>key</param> for <func>msgget()</func>.  Programs
that want to use the same queue must generate the same
<param>key</param>, so they must pass the same parameters to
<func>ftok()</func>.</p>

<p>Finally, it's time to make the call:</p>

<code>
#include &lt;sys/msg.h&gt;

key = ftok("/home/beej/somefile", 'b');
msqid = msgget(key, 0666 | IPC_CREAT);
</code>

<p>In the above example, I set the permissions on the queue to
<tt>666</tt> (or <tt>rw-rw-rw-</tt>, if that makes more sense to you).
And now we have <var>msqid</var> which will be used to send and receive
messages from the queue.</p>

</sect2>

<sect2 id="mqsend">
<title>Sending to the queue</title>

<p>Once you've connected to the message queue using <func>msgget()</func>,
you are ready to send and receive messages.  First, the sending:</p>

<p>Each message is made up of two parts, which are defined in the template
structure <type>struct msgbuf</type>, as defined in
<file>sys/msg.h</file>:</p>

<code>struct msgbuf {
	long mtype;
	char mtext[1];
};</code>

<p>The field <var>mtype</var> is used later when retrieving messages
from the queue, and can be set to any positive number.  <var>mtext</var>
is the data this will be added to the queue.</p>

<p>"What?!  You can only put one byte arrays onto a message queue?!
Worthless!!"  Well, not exactly.  You can use any structure you want to
put messages on the queue, as long as the first element is a long.  For
instance, we could use this structure to store all kinds of goodies:</p>

<code>struct pirate_msgbuf {
	long mtype;  /* must be positive */
	struct pirate_info {
		char name[30];
		char ship_type;
		int notoriety;
		int cruelty;
		int booty_value;
	} info;
};</code>

<p>Ok, so how do we pass this information to a message queue?  The answer
is simple, my friends: just use <func>msgsnd()</func>:</p>

<code>int msgsnd(int <param>msqid</param>, const void *<param>msgp</param>,
           size_t <param>msgsz</param>, int <param>msgflg</param>);</code>

<p><param>msqid</param> is the message queue identifier returned by
<func>msgget()</func>.  The pointer <param>msgp</param> is a pointer to
the data you want to put on the queue.  <param>msgsz</param> is the size
in bytes of the data to add to the queue (not counting the size of the
<var>mtype</var> member).  Finally, <param>msgflg</param> allows you to
set some optional flag parameters, which we'll ignore for now by setting
it to <const>0</const>.</p>

<p>The best way to get the size of the data to send is by setting it up
correctly to begin with. The first field of the <type>struct</type>
should be a <type>long</type>, as we've seen. To be safe and portable,
there should only be one additional field. If you need more than one,
wrap it up in a <type>struct</type> like with <nobr><type>struct
pirate_msgbuf</type></nobr>, above.</p>

<p>When to get the size of the data to send, just take the size of the
second field:</p>

<code><![CDATA[struct cheese_msgbuf {
	long mtype;
	char name[20];
};

/* calculate the size of the data to send: */

struct cheese_msgbuf mbuf;
int size;

size = sizeof mbuf.name;

/* Or, without a declared variable: */

size = sizeof ((struct cheese_msgbuf*)0)->name;]]></code>

<p>Or, if you have a lot of different fields, put them in a
<type>struct</type> and use the <operator>sizeof</operator> operator on
that. It can be extra convenient to do this, because now the
substructure can have a name to reference. Here is a code snippet that
shows one of our pirate structures being added to the message queue:</p>

<code><![CDATA[#include <sys/msg.h>
#include <stddef.h>

key_t key;
int msqid;
struct pirate_msgbuf pmb = {2, { "L'Olonais", 'S', 80, 10, 12035 } };

key = ftok("/home/beej/somefile", 'b');
msqid = msgget(key, 0666 | IPC_CREAT);

/* stick him on the queue */
/* struct pirate_info is the sub-structure */
msgsnd(msqid, &pmb, sizeof(struct pirate_info), 0);]]></code>

<p>Aside from remembering to error-check the return values from all
these functions, this is all there is to it.  Oh, yeah: note that I
arbitrarily set the <var>mtype</var> field to <const>2</const> up there.
That'll be important in the next section.</p>

</sect2>

<sect2 id="mqrece">
<title>Receiving from the queue</title>

<p>Now that we have the dreaded pirate <ulink url="&lolonais;">Francis
L'Olonais</ulink> stuck in our message queue, how do we get him out?  As
you can imagine, there is a counterpart to <func>msgsnd()</func>: it is
<func>msgrcv()</func>.  How imaginative.</p>

<p>A call to <func>msgrcv()</func> that would do it looks something like
this:</p>

<code><![CDATA[#include <sys/msg.h>
#include <stddef.h>

key_t key;
int msqid;
struct pirate_msgbuf pmb; /* where L'Olonais is to be kept */

key = ftok("/home/beej/somefile", 'b');
msqid = msgget(key, 0666 | IPC_CREAT);

/* get him off the queue! */
msgrcv(msqid, &pmb, sizeof(struct pirate_info), 2, 0);]]></code>

<p>There is something new to note in the <func>msgrcv()</func> call: the
<const>2</const>!  What does it mean?  Here's the synopsis of the
call:</p>

<code>
int msgrcv(int <param>msqid</param>, void *<param>msgp</param>, size_t <param>msgsz</param>, long <param>msgtyp</param>, int <param>msgflg</param>);</code>

<p>The <const>2</const> we specified in the call is the requested
<param>msgtyp</param>.  Recall that we set the <param>mtype</param>
arbitrarily to <const>2</const> in the <func>msgsnd()</func> section of
this document, so that will be the one that is retrieved from the
queue.</p>

<p>Actually, the behavior of <func>msgrcv()</func> can be modified
drastically by choosing a <param>msgtyp</param> that is positive,
negative, or zero:</p>

<table border="0">
<tr><td width="20%"><th><param>msgtyp</param></th></td>
<td width="80%"><th>Effect on <func>msgrcv()</func></th></td></tr>

<tr><td>Zero</td>
<td>Retrieve the next message on the queue, regardless of its
<var>mtype</var>.</td></tr>

<tr><td>Positive</td>
<td>Get the next message with an <var>mtype</var>
<emp>equal to</emp> the specified <param>msgtyp</param>.</td></tr>

<tr><td>Negative</td>
<td>Retrieve the first message on the queue whose <var>mtype</var> field
is less than or equal to the absolute value of the <param>msgtyp</param>
argument.</td></tr>

</table>
<!-- <b>Table 1.  Effects of the <param>msgtyp</param> argument on
<tt>msgrcv()</tt>.</b> -->

<p>So, what will often be the case is that you'll simply want the next
message on the queue, no matter what <var>mtype</var> it is.  As such,
you'd set the <param>msgtyp</param> parameter to <const>0</const>.</p>

</sect2>

<sect2 id="mqdest">
<title>Destroying a message queue</title>

<p>There comes a time when you have to destroy a message queue.  Like I
said before, they will stick around until you explicitly remove them; it
is important that you do this so you don't waste system resources.  Ok,
so you've been using this message queue all day, and it's getting old.
You want to obliterate it.  There are two ways:</p>

<numlist>
<li>Use the Unix command <com>ipcs</com> to get a list of defined
message queues, then use the command <com>ipcrm</com> to delete the
queue.</li>

<li>Write a program to do it for you.</li>

</numlist>

<p>Often, the latter choice is the most appropriate, since you might
want your program to clean up the queue at some time or another.  To do
this requires the introduction of another function:
<func>msgctl()</func>.</p>

<p>The synopsis of <func>msgctl()</func> is:</p>

<code>int msgctl(int <param>msqid</param>, int <param>cmd</param>,
           struct msqid_ds *<param>buf</param>);</code>

<p>Of course, <param>msqid</param> is the queue identifier obtained from
<func>msgget()</func>.  The important argument is <param>cmd</param>
which tells <func>msgctl()</func> how to behave.  It can be a variety of
things, but we're only going to talk about <const>IPC_RMID</const>,
which is used to remove the message queue.  The <param>buf</param>
argument can be set to <const>NULL</const> for the purposes of
<const>IPC_RMID</const>.</p>

<p>Say that we have the queue we created above to hold the pirates.  You
can destroy that queue by issuing the following call:</p>

<code><![CDATA[#include <sys/msg.h>
.
.
msgctl(msqid, IPC_RMID, NULL);]]></code>

<p>And the message queue is no more.
(Of course, error checking of these return values is always appropriate!)</p>

</sect2>

<!-- ======================================================= -->
<!-- Message queues: Sample programs, anyone? -->
<!-- ======================================================= -->

<sect2 id="mqsamp">
<title>Sample programs, anyone?</title>

<p>For the sake of completeness, I'll include a brace of programs that
will communicate using message queues.  The first, <file>kirk.c</file>
adds messages to the message queue, and <file>spock.c</file> retrieves
them.</p>

<p>Here is the source for <ulink
url="&samplepre;kirk.c">kirk.c</ulink>:</p>

<code><![CDATA[#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <string.h>
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/msg.h>

struct my_msgbuf {
	long mtype;
	char mtext[200];
};

int main(void)
{
	struct my_msgbuf buf;
	int msqid;
	key_t key;

	if ((key = ftok("kirk.c", 'B')) == -1) {
		perror("ftok");
		exit(1);
	}

	if ((msqid = msgget(key, 0644 | IPC_CREAT)) == -1) {
		perror("msgget");
		exit(1);
	}
	
	printf("Enter lines of text, ^D to quit:\n");

	buf.mtype = 1; /* we don't really care in this case */

	while(fgets(buf.mtext, sizeof buf.mtext, stdin) != NULL) {
		int len = strlen(buf.mtext);

		/* ditch newline at end, if it exists */
		if (buf.mtext[len-1] == '\n') buf.mtext[len-1] = '\0';

		if (msgsnd(msqid, &buf, len, 0) == -1)
			perror("msgsnd");
	}

	if (msgctl(msqid, IPC_RMID, NULL) == -1) {
		perror("msgctl");
		exit(1);
	}

	return 0;
}]]></code>

<p>The way <com>kirk</com> works is that it allows you to enter lines of
text.  Each line is bundled into a message and added to the message
queue.  The message queue is then read by <com>spock</com>.</p>

<p>Here is the source for <ulink
url="&samplepre;spock.c">spock.c</ulink>:</p>

<code><![CDATA[#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/msg.h>

struct my_msgbuf {
	long mtype;
	char mtext[200];
};

int main(void)
{
	struct my_msgbuf buf;
	int msqid;
	key_t key;

	if ((key = ftok("kirk.c", 'B')) == -1) {  /* same key as kirk.c */
		perror("ftok");
		exit(1);
	}

	if ((msqid = msgget(key, 0644)) == -1) { /* connect to the queue */
		perror("msgget");
		exit(1);
	}
	
	printf("spock: ready to receive messages, captain.\n");

	for(;;) { /* Spock never quits! */
		if (msgrcv(msqid, &buf, sizeof buf.mtext, 0, 0) == -1) {
			perror("msgrcv");
			exit(1);
		}
		printf("spock: \"%s\"\n", buf.mtext);
	}

	return 0;
}]]></code>

<p>Notice that <com>spock</com>, in the call to <func>msgget()</func>,
doesn't include the <const>IPC_CREAT</const> option.  We've left it up
to <com>kirk</com> to create the message queue, and <com>spock</com>
will return an error if he hasn't done so.</p>

<p>Notice what happens when you're running both in separate windows and
you kill one or the other.  Also try running two copies of
<com>kirk</com> or two copies of <com>spock</com> to get an idea of what
happens when you have two readers or two writers.  Another interesting
demonstration is to run <com>kirk</com>, enter a bunch of messages, then
run <com>spock</com> and see it retrieve all the messages in one swoop.
Just messing around with these toy programs will help you gain an
understanding of what is really going on.</p>

</sect2>

<sect2 id="mqsum">
<title>Summary</title>

<p>There is more to message queues than this short tutorial can present.
Be sure to look in the man pages to see what else you can do, especially
in the area of <func>msgctl()</func>.  Also, there are more options you
can pass to other functions to control how <func>msgsnd()</func> and
<func>msgrcv()</func> handle if the queue is full or empty,
respectively.</p>

</sect2>

</sect1> <!-- Message Queues -->

<!-- ======================================================= -->
<!-- Semaphores -->
<!-- ======================================================= -->

<sect1 id="semaphores">
<title>Semaphores</title>

<p>Remember <link dest="flocking">file locking</link>?  Well, semaphores
can be thought of as really generic advisory locking mechanisms.  You
can use them to control access to files, <link dest="shm">shared
memory</link>, and, well, just about anything you want.  The basic
functionality of a semaphore is that you can either set it, check it, or
wait until it clears then set it ("test-n-set").  No matter how complex
the stuff that follows gets, remember those three operations.</p>

<p>This document will provide an overview of semaphore functionality,
and will end with a program that uses semaphores to control access to a
file.  (This task, admittedly, could easily be handled with file
locking, but it makes a good example since it's easier to wrap your head
around than, say, shared memory.)</p>

<!-- ======================================================= -->
<!-- Grabbing some semaphores -->
<!-- ======================================================= -->

<sect2 id="semgrab">
<title>Grabbing some semaphores</title>

<p>With System V IPC, you don't grab single semaphores; you grab
<emp>sets</emp> of semaphores.  You can, of course, grab a semaphore set
that only has one semaphore in it, but the point is you can have a whole
slew of semaphores just by creating a single semaphore set.</p>

<p>How do you create the semaphore set?  It's done with a call to
<func>semget()</func>, which returns the semaphore id (hereafter referred to
as the <var>semid</var>):</p>

<code>#include &lt;sys/sem.h&gt;

int semget(key_t <param>key</param>, int <param>nsems</param>, int <param>semflg</param>);</code>

<p>What's the <param>key</param>?  It's a unique identifier that is used
by different processes to identify this semaphore set.  (This
<param>key</param> will be generated using <func>ftok()</func>,
described in the <link dest="mqftok">Message Queues section</link>.)</p>

<p>The next argument, <param>nsems</param>, is (you guessed it!) the
number of semaphores in this semaphore set.  The maximum number is system
dependent, but it's probably around 32000.  If you're needing
more (greedy wretch!), just get another semaphore set. You may pass
<const>0</const> if you're connecting to an existing semaphore
set, but you must specify a positive number if you're creating
a new semaohore set.</p>

<p>Finally, there's the <param>semflg</param> argument.  This tells
<func>semget()</func> what the permissions should be on the new semaphore
set, whether you're creating a new set or just want to connect to an
existing one, and other things that you can look up.  For creating a new
set, permissions can be bitwise-OR'd with
<const>IPC_CREAT</const>.</p>

<p>Here's an example call that generates the <param>key</param> with
<func>ftok()</func> and creates a 10 semaphore set, with 666
(<tt>rw-rw-rw-</tt>) permissions:</p>

<code>#include &lt;sys/ipc.h&gt;
#include &lt;sys/sem.h&gt;

key_t key;
int semid;

key = ftok("/home/beej/somefile", 'E');
semid = semget(key, 10, 0666 | IPC_CREAT);</code>

<p>Congrats!  You've created a new semaphore set!  After running the
program you can check it out with the <com>ipcs</com> command.  (Don't
forget to remove it when you're done with it with <com>ipcrm</com>!)</p>

<p>Wait!  Warning!  <foreign>&#x00A1;Advertencia! &#x00A1;No pongas las
manos en la tolva!</foreign>  (That's the only Spanish I learned while
working at Pizza Hut in 1990.  It was printed on the dough roller.)
Look here:</p>

<p>When you first create some semaphores, they're all uninitialized; it
takes another call to mark them as free (namely to <func>semop()</func>
or <func>semctl()</func>&emdash;see the following sections.) What does
this mean?  Well, it means that creation of a semaphore is not
<emp>atomic</emp> (in other words, it's not a one-step process).  If two
processes are trying to create, initialize, and use a semaphore at the
same time, a race condition might develop.</p>

<p>One way to get around this difficulty is by having a single init
process that creates and initializes the semaphore long before the
main processes begin to run.  The main process just accesses it, but
never creates nor destroys it.</p>

<p>Stevens refers to this problem as the semaphore's "fatal flaw".  He
solves it by creating the semaphore set with the <const>IPC_EXCL</const>
flag.  If process 1 creates it first, process 2 will return an error on
the call (with <var>errno</var> set to <const>EEXIST</const>.)  At that
point, process 2 will have to wait until the semaphore is initialized by
process 1.  How can it tell?  Turns out, it can repeatedly call
<func>semctl()</func> with the <const>IPC_STAT</const> flag, and look at
the <var>sem_otime</var> member of the returned <type>struct
semid_ds</type> structure.  If that's non-zero, it means process 1 has
performed an operation on the semaphore with <func>semop()</func>,
presumably to initialize it.</p>

<p>For an example of this, see the demonstration program <link
dest="semsamp"><file>semdemo.c</file></link>, below, in which I
generally reimplement <ulink url="&unpurl;">Stevens' code</ulink>.</p>

<p>In the meantime, let's hop to the next section and take a look at how
to initialize our freshly-minted semaphores.</p>

</sect2>

<!-- ======================================================= -->
<!-- Controlling semaphores -->
<!-- ======================================================= -->

<sect2 id="semctl">
<title>Controlling your semaphores with <func>semctl()</func></title>

<p>Once you have created your semaphore sets, you have to initialize
them to a positive value to show that the resource is available to use.
The function <func>semctl()</func> allows you to do atomic value changes
to individual semaphores or complete sets of semaphores.</p>

<code>int semctl(int <param>semid</param>, int <param>semnum</param>,
           int <param>cmd</param>, ... /*<param>arg</param>*/);</code>

<p><param>semid</param> is the semaphore set id that you get from your
call to <func>semget()</func>, earlier.  <param>semnum</param> is the ID
of the semaphore that you wish to manipulate the value of. 
<param>cmd</param> is what you wish to do with the semaphore in
question.  The last "argument", "<param>arg</param>", if required, needs
to be a <type>union semun</type>, which will be defined by you in your
code to be one of these:</p>

<code>union semun {
    int val;               /* used for SETVAL only */
    struct semid_ds *buf;  /* used for IPC_STAT and IPC_SET */
    ushort *array;         /* used for GETALL and SETALL */
};</code>

<p>(Note that <type>union semun</type> is now defined in the header
files of modern Linux systems.  However, I don't know what feature
test macro to use to determine this, so only define this union if
your system doesn't already.  Read the docs for <func>semctl()</func>
for more information.)</p>

<p>The various fields in the <type>union semun</type> are used depending
on the value of the <param>cmd</param> parameter to
<func>semctl()</func> (a partial list follows&emdash;see your local man
page for more):</p>

<table border="0">
<tr><td width="20%"><param><th>cmd</th></param></td>
<td width="80%"><th>Effect</th></td></tr>

<tr><td><const>SETVAL</const></td>
<td>Set the value of the specified semaphore to the value in the
<var>val</var> member of the passed-in <type>union
semun</type>.</td></tr>

<tr><td><const>GETVAL</const></td>
<td>Return the value of the given semaphore.</td></tr>

<tr><td><const>SETALL</const></td>
<td>Set the values of all the semaphores in the set to the values in the
array pointed to by the <var>array</var> member of the passed-in
<type>union semun</type>.  The <param>semnum</param> parameter to
<func>semctl()</func> isn't used.</td></tr>

<tr><td><const>GETALL</const></td>
<td>Gets the values of all the semaphores in the set and stores them in
the array pointed to by the <var>array</var> member of the passed-in
<type>union semun</type>.  The <param>semnum</param> parameter to
<func>semctl()</func> isn't used.</td></tr>

<tr><td><const>IPC_RMID</const></td>
<td>Remove the specified semaphore set from the system.  The
<param>semnum</param> parameter is ignored.</td></tr>

<tr><td><const>IPC_STAT</const></td>
<td>Load status information about the semaphore set into the
<type>struct semid_ds</type> structure pointed to by the <var>buf</var>
member of the <type>union semun</type>.</td></tr>

</table>

<p>For the curious, here are the (abbreviated) contents of the <type>struct
semid_ds</type> that is used in the <type>union semun</type>:</p>

<code>struct semid_ds {
    struct ipc_perm sem_perm;  /* Ownership and permissions
    time_t          sem_otime; /* Last semop time */
    time_t          sem_ctime; /* Last change time */
    unsigned short  sem_nsems; /* No. of semaphores in set */
};</code>

<p>We'll use that <var>sem_otime</var> member later on when we write our
<func>initsem()</func> in the sample code, below.</p>

</sect2>

<!-- ======================================================= -->
<!-- semop(): Atomic power! -->
<!-- ======================================================= -->

<sect2 id="semop">
<title><tt>semop()</tt>: Atomic power!</title>

<p>All operations that set, get, or test-n-set a semaphore use the
<func>semop()</func> system call.  This system call is general purpose,
and its functionality is dictated by a structure that is passed to it,
<nobr><type>struct sembuf</type></nobr>:</p>

<code>/* Warning!  Members might not be in this order! */

struct sembuf {
    ushort sem_num;
    short sem_op;
    short sem_flg;
};</code>

<p>Of course, <var>sem_num</var> is the number of the semaphore in the
set that you want to manipulate.  Then, <var>sem_op</var> is what you
want to do with that semaphore.  This takes on different meanings,
depending on whether <var>sem_op</var> is positive, negative, or zero,
as shown in the following table:</p>

<table border="0">
<tr><td width="15%"><th><var>sem_op</var></th></td>
<td width="85%"><th>What happens</th></td></tr>

<tr><td>Negative</td>
<td>Allocate resources.  Block the calling process until the value of
the semaphore is greater than or equal to the absolute value of
<var>sem_op</var>.  (That is, wait until enough resources have been
freed by other processes for this one to allocate.)  Then add
(effectively subtract, since it's negative) the value of
<var>sem_op</var> to the semaphore's value.</td></tr>

<tr><td>Positive</td>
<td>Release resources.  The value of <var>sem_op</var> is added to
the semaphore's value.</td></tr>

<tr><td>Zero</td>
<td>This process will wait until the semaphore in question reaches
0.</td></tr>

</table>
<!-- <b>Table 1.  <tt>sem_op</tt> values and their effects.</b> -->

<p>So, basically, what you do is load up a <nobr><type>struct
sembuf</type></nobr> with whatever values you want, then call
<func>semop()</func>, like this:</p>

<code>int semop(int <param>semid</param>, struct sembuf *<param>sops</param>,
          unsigned int <param>nsops</param>);</code>

<p>The <param>semid</param> argument is the number obtained from the
call to <func>semget()</func>.  Next is <param>sops</param>, which is a
pointer to the <nobr><type>struct sembuf</type></nobr> that you filled
with your semaphore commands.  If you want, though, you can make an
array of <nobr><type>struct sembuf</type></nobr>s in order to do a whole
bunch of semaphore operations at the same time.  The way
<func>semop()</func> knows that you're doing this is the
<param>nsop</param> argument, which tells how many <nobr><type>struct
sembuf</type></nobr>s you're sending it.  If you only have one, well,
put <const>1</const> as this argument.</p>

<p>One field in the <nobr><type>struct sembuf</type></nobr> that I
haven't mentioned is the <var>sem_flg</var> field which allows the
program to specify flags to further modify the effects of the
<func>semop()</func> call.</p>

<p>One of these flags is <const>IPC_NOWAIT</const> which, as the name
suggests, causes the call to <func>semop()</func> to return with error
<const>EAGAIN</const> if it encounters a situation where it would
normally block.  This is good for situations where you might want to
"poll" to see if you can allocate a resource.</p>

<p>Another very useful flag is the <const>SEM_UNDO</const> flag.  This
causes <func>semop()</func> to record, in a way, the change made to the
semaphore.  When the program exits, the kernel will automatically undo
all changes that were marked with the <const>SEM_UNDO</const> flag.  Of
course, your program should do its best to deallocate any resources it
marks using the semaphore, but sometimes this isn't possible when your
program gets a <const>SIGKILL</const> or some other awful crash
happens.</p>

</sect2>

<!-- ======================================================= -->
<!-- Destroying a semaphore -->
<!-- ======================================================= -->

<sect2 id="semdest">
<title>Destroying a semaphore</title>

<p>There are two ways to get rid of a semaphore: one is to use the Unix
command <com>ipcrm</com>.  The other is through a call to
<func>semctl()</func> with the <param>cmd</param> set to
<const>IPC_RMID</const>.</p>

<p>Basically, you want to call <func>semctl()</func> and set
<param>semid</param> to the semaphore ID you want to axe.  The
<param>cmd</param> should be set to <const>IPC_RMID</const>, which tells
<func>semctl()</func> to remove this semaphore set.  The parameter
<param>semnum</param> has no meaning in the <const>IPC_RMID</const>
context and can just be set to zero.</p>

<p>Here's an example call to torch a semaphore set:</p>

<code>int semid; 
.
.
semid = semget(...);
.
.
semctl(semid, 0, IPC_RMID);</code>

<p>Easy peasy.</p>

</sect2>

<!-- ======================================================= -->
<!-- Semaphore: Sample programs -->
<!-- ======================================================= -->

<sect2 id="semsamp">
<title>Sample programs</title>

<p>There are two of them.  The first, <file>semdemo.c</file>, creates
the semaphore if necessary, and performs some pretend file locking on it
in a demo very much like that in the <link dest="flocking">File
Locking</link> document.  The second program, <file>semrm.c</file> is
used to destroy the semaphore (again, <com>ipcrm</com> could be used to
accomplish this.)</p>

<p>The idea is to run run <file>semdemo.c</file> in a few windows and
see how all the processes interact.  When you're done, use
<file>semrm.c</file> to remove the semaphore.  You could also try
removing the semaphore while running <file>semdemo.c</file> just to see
what kinds of errors are generated.</p>

<p>Here's <ulink
url="&samplepre;semdemo.c"><file>semdemo.c</file></ulink>, including a
function named <func>initsem()</func> that gets around the semaphore
race conditions, Stevens-style:</p>

<code><![CDATA[#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <errno.h>
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/sem.h>

#define MAX_RETRIES 10

#ifdef NEED_SEMUN
/* Defined in sys/sem.h as required by POSIX now */
union semun {
    int val;
    struct semid_ds *buf;
    ushort *array;
};
#endif

/*
** initsem() -- more-than-inspired by W. Richard Stevens' UNIX Network
** Programming 2nd edition, volume 2, lockvsem.c, page 295.
*/
int initsem(key_t key, int nsems)  /* key from ftok() */
{
    int i;
    union semun arg;
    struct semid_ds buf;
    struct sembuf sb;
    int semid;

    semid = semget(key, nsems, IPC_CREAT | IPC_EXCL | 0666);

    if (semid >= 0) { /* we got it first */
            sb.sem_op = 1; sb.sem_flg = 0;
            arg.val = 1;

            printf("press return\n"); getchar();

            for(sb.sem_num = 0; sb.sem_num < nsems; sb.sem_num++) { 
                    /* do a semop() to "free" the semaphores. */
                    /* this sets the sem_otime field, as needed below. */
                    if (semop(semid, &sb, 1) == -1) {
                            int e = errno;
                            semctl(semid, 0, IPC_RMID); /* clean up */
                            errno = e;
                            return -1; /* error, check errno */
                    }
            }

    } else if (errno == EEXIST) { /* someone else got it first */
            int ready = 0;

            semid = semget(key, nsems, 0); /* get the id */
            if (semid < 0) return semid; /* error, check errno */

            /* wait for other process to initialize the semaphore: */
            arg.buf = &buf;
            for(i = 0; i < MAX_RETRIES && !ready; i++) {
                    semctl(semid, nsems-1, IPC_STAT, arg);
                    if (arg.buf->sem_otime != 0) {
                            ready = 1;
                    } else {
                            sleep(1);
                    }
            }
            if (!ready) {
                    errno = ETIME;
                    return -1;
            }
    } else {
            return semid; /* error, check errno */
    }

    return semid;
}

int main(void)
{
    key_t key;
    int semid;
    struct sembuf sb;
    
    sb.sem_num = 0;
    sb.sem_op = -1;  /* set to allocate resource */
    sb.sem_flg = SEM_UNDO;

    if ((key = ftok("semdemo.c", 'J')) == -1) {
            perror("ftok");
            exit(1);
    }

    /* grab the semaphore set created by seminit.c: */
    if ((semid = initsem(key, 1)) == -1) {
            perror("initsem");
            exit(1);
    }

    printf("Press return to lock: ");
    getchar();
    printf("Trying to lock...\n");

    if (semop(semid, &sb, 1) == -1) {
            perror("semop");
            exit(1);
    }

    printf("Locked.\n");
    printf("Press return to unlock: ");
    getchar();

    sb.sem_op = 1; /* free resource */
    if (semop(semid, &sb, 1) == -1) {
            perror("semop");
            exit(1);
    }

    printf("Unlocked\n");

    return 0;
}]]></code>

<p>Here's <ulink url="&samplepre;semrm.c"><file>semrm.c</file></ulink>
for removing the semaphore when you're done:</p>

<code><![CDATA[#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/sem.h>

int main(void)
{
    key_t key;
    int semid;
    union semun arg;

    if ((key = ftok("semdemo.c", 'J')) == -1) {
            perror("ftok");
            exit(1);
    }

    /* grab the semaphore set created by seminit.c: */
    if ((semid = semget(key, 1, 0)) == -1) {
            perror("semget");
            exit(1);
    }

    /* remove it: */
    if (semctl(semid, 0, IPC_RMID, 0) == -1) {
            perror("semctl");
            exit(1);
    }

    return 0;
}]]></code>

<p>Isn't that fun!  I'm sure you'll give up Quake just to play with this
semaphore stuff all day long!</p>

</sect2>

<!-- ======================================================= -->
<!-- Semaphore summary -->
<!-- ======================================================= -->

<sect2 id="semsum">
<title>Summary</title>

<p>I might have understated the usefulness of semaphores.  I assure you,
they're very very very useful in a concurrency situation.  They're often
faster than regular file locks, too.  Also, you can use them on other
things that aren't files, such as <link dest="shm">Shared Memory
Segments</link>!  In fact, it is sometimes hard to live without them,
quite frankly.</p>

<p>Whenever you have multiple processes running through a critical
section of code, man, you need semaphores.  You have zillions of
them&emdash;you might as well use 'em.</p>

</sect2>

</sect1> <!-- Semaphores -->

<!-- ======================================================= -->
<!-- Shared Memory Segments -->
<!-- ======================================================= -->

<sect1 id="shm">
<title>Shared Memory Segments</title>

<p>The cool thing about shared memory segments is that they are what
they sound like: a segment of memory that is shared between processes.
I mean, think of the potential of this!  You could allocate a block of
player information for a multi-player game and have each process access
it at will!  Fun, fun, fun.  (Of course, memory-mapped files accomplish
the same thing and have the added advantage of persistence, albeit with
the same caveats that apply to shared memory.)</p>

<p>There are, as usual, more gotchas to watch out for, but it's all
pretty easy in the long run.  See, you just connect to the shared memory
segment, and get a pointer to the memory.  You can read and write to
this pointer and all changes you make will be visible to everyone else
connected to the segment.  There is nothing simpler.  Well, there is,
actually, but I was just trying to make you more comfortable.</p>

<sect2 id="shmcreat">
<title>Creating the segment and connecting</title>

<p>Similarly to other forms of System V IPC, a shared memory segment is
created and connected to via the <func>shmget()</func> call:</p>

<code>int shmget(key_t <param>key</param>, size_t <param>size</param>,
           int <param>shmflg</param>);</code>

<p>Upon successful completion, <func>shmget()</func> returns an
identifier for the shared memory segment.  The <param>key</param>
argument should be created the same was as shown in the <link
dest="mqftok">Message Queues</link> document, using <func>ftok()</func>.
The next argument, <param>size</param>, is the size in bytes of the
shared memory segment.  Finally, the <param>shmflg</param> should be set
to the permissions of the segment bitwise-OR'd with
<const>IPC_CREAT</const> if you want to create the segment, but can be
<const>0</const> otherwise.  (It doesn't hurt to specify
<const>IPC_CREAT</const> every time&emdash;it will simply connect you if
the segment already exists.)</p>

<p>Here's an example call that creates a 1K segment with <tt>644</tt>
permissions (<tt>rw-r--r--</tt>):</p>

<code>key_t key;
int shmid;

key = ftok("/home/beej/somefile3", 'R');
shmid = shmget(key, 1024, 0644 | IPC_CREAT);</code>

<p>(It may not be possible to actually create a 1K segment, as the
operating system is allowed to increase the size to fit any internal
constraints it may have.  For example, on a system with 4K virtual
pages, it's likely the size will be increased to 4K.  Of course,
your program won't know or care; this is just an implementation
detail.)</p>

<p>But how do you get a pointer to that data from the <var>shmid</var>
handle?  The answer is in the call <func>shmat()</func>, in the
following section.</p>

</sect2>

<sect2 id="shmat">
<title>Attach me&emdash;getting a pointer to the segment</title>

<p>Before you can use a shared memory segment, you have to attach yourself
to it using the <func>shmat()</func> call:</p>

<code>void *shmat(int <param>shmid</param>, void *<param>shmaddr</param>, int <param>shmflg</param>);</code>

<p>What does it all mean?  Well, <param>shmid</param> is the shared
memory ID you got from the call to <func>shmget()</func>.  Next is
<param>shmaddr</param>, which you can use to tell <func>shmat()</func>
which specific address to use but you should just set it to
<const>0</const> and let the OS choose the address for you.  Finally,
the <param>shmflg</param> can be set to <const>SHM_RDONLY</const> if you
only want to read from it, <const>0</const> otherwise.  (Check the man pages
for other useful flags that can be included.)</p>

<p>Here's a more complete example of how to get a pointer to a shared
memory segment:</p>

<code>key_t key;
int shmid;
char *data;

key = ftok("/home/beej/somefile3", 'R');
shmid = shmget(key, 1024, 0644 | IPC_CREAT);
data = shmat(shmid, (void *)0, 0);</code>

<p>And <emp>bammo</emp>!  You have the pointer to the shared memory
segment!  Notice that <func>shmat()</func> returns a <type>void</type>
pointer, and we're treating it, in this case, as a <type>char</type>
pointer.  You can treat it as anything you like, depending on what kind
of data you have in there.  Pointers to arrays of structures are just as
acceptable as anything else.</p>

<p>Also, it's interesting to note that <func>shmat()</func> returns
<const>-1</const> on failure (as does <func>mmap()</func>).
But how do you get <const>-1</const> in a
<type>void</type> pointer?  Just do a cast during the comparison to
check for errors:</p>

<code>data = shmat(shmid, (void *)0, 0);
if (data == MAP_FAILED)
    perror("shmat");</code>

<p>(It's important to note that the integer is being cast to a pointer,
and not the pointer return value being cast to an integer.  It's a
subtle difference, but the latter is not always portable between
architectures.  Also note that the cast is to <type>void*</type>
and not <type>char*</type>, as you might expect.  Since the language
guarantees that implicit casts from <type>void*</type> to any other
kind of pointer are always safe and reliable, it's better to use
<type>void*</type> and let the compiler to the work.)</p>

<p>All you have to do now is change the data it points to normal
pointer-style. There are some samples in the next section.</p>

</sect2>

<sect2 id="shmrw">
<title>Reading and Writing</title>

<p>Lets say you have the <var>data</var> pointer from the above example.
It is a <type>char</type> pointer, so we'll be reading and writing chars
from it.  Furthermore, for the sake of simplicity, lets say the 1K
shared memory segment contains a null-terminated string.</p>

<p>It couldn't be easier.  Since it's just a string in there, we can
print it like this:</p>

<code>printf("shared contents: %s\n", data);</code>

<p>And we could store something in it as easily as this:</p>

<code>printf("Enter a string: ");
fgets(data, 1024, stdin);</code>

<p>Of course, like I said earlier, you can have other data in there
besides just <type>char</type>s.  I'm just using them as an example.
I'll just make the assumption that you're familiar enough with pointers
in C that you'll be able to deal with whatever kind of data you stick in
there.</p>

</sect2>

<sect2 id="shmdet">
<title>Detaching from and deleting segments</title>

<p>When you're done with the shared memory segment, your program should
detach itself from it using the <func>shmdt()</func> call (if you don't,
this will happen automatically when the process terminates):</p>

<code>int shmdt(void *<param>shmaddr</param>);</code>

<p>The only argument, <param>shmaddr</param>, is the address you got
from <func>shmat()</func>.  The function returns <const>-1</const> on
error, <const>0</const> on success.</p>

<p>When you detach from the segment, it isn't destroyed.  Nor is it
removed when <emp>everyone</emp> detaches from it.  You have to
specifically destroy it using a call to <func>shmctl()</func>, similar
to the control calls for the other System V IPC functions:</p>

<code>shmctl(shmid, IPC_RMID, NULL);</code>

<p>The above call deletes the shared memory segment, assuming no one
else is attached to it.  The <func>shmctl()</func> function does a lot
more than this, though, and is worth looking into.  (On your own, of
course, since this is only an overview!)</p>

<p>As always, you can destroy the shared memory segment from the command
line using the <com>ipcrm</com> Unix command.  Also, be sure that you
don't leave any unused shared memory segments sitting around wasting
system resources.  All the System V IPC objects you own can be viewed
using the <com>ipcs</com> command.</p>

</sect2>

<sect2 id="shmcon">
<title>Concurrency</title>

<p>What are concurrency issues?  Well, since you have multiple processes
modifying the shared memory segment, it is possible that certain errors
could crop up when updates to the segment occur simultaneously.  This
<emp>concurrent</emp> access is almost always a problem when you have
multiple writers to a shared object.</p>

<p>The way to get around this is to use <link
dest="semaphores">Semaphores</link> to lock the shared memory segment
while a process is writing to it.  (Sometimes the lock will encompass
both a read and write to the shared memory, depending on what you're
doing.)</p>

<p>A true discussion of concurrency is beyond the scope of this paper,
and you might want to check out the <ulink url="&wpconcur;">Wikipedia
article on the matter</ulink>.  I'll just leave it with this: if you
start getting weird inconsistencies in your shared data when you connect
two or more processes to it, you could very well have a concurrency
problem.</p>

</sect2>

<sect2 id="shmsam">
<title>Sample code</title>

<p>Now that I've primed you on all the dangers of concurrent access to a
shared memory segment without using semaphores, I'll show you a demo
that does just that.  Since this isn't a mission-critical application,
and it's unlikely that you'll be accessing the shared data at the same
time as any other process, I'll just leave the semaphores out for the
sake of simplicity.</p>

<p>This program does one of two things: if you run it with no command
line parameters, it prints the contents of the shared memory segment.
If you give it one command line parameter, it stores that parameter in
the shared memory segment.</p>

<p>Here's the code for <ulink
url="&samplepre;shmdemo.c">shmdemo.c</ulink>:</p>

<code><![CDATA[#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/shm.h>

#define SHM_SIZE 1024  /* make it a 1K shared memory segment */

int main(int argc, char *argv[])
{
    key_t key;
    int shmid;
    char *data;
    int mode;

    if (argc > 2) {
            fprintf(stderr, "usage: shmdemo [data_to_write]\n");
            exit(1);
    }

    /* make the key: */
    if ((key = ftok("shmdemo.c", 'R')) == -1) {
            perror("ftok");
            exit(1);
    }

    /* connect to (and possibly create) the segment: */
    if ((shmid = shmget(key, SHM_SIZE, 0644 | IPC_CREAT)) == -1) {
            perror("shmget");
            exit(1);
    }

    /* attach to the segment to get a pointer to it: */
    data = shmat(shmid, (void *)0, 0);

    /* we _could_ use MAP_FAILED, but technically that's not */
    /* the defined return value.  System V failed on this one! */
    if (data == (void *)(-1)) {
            perror("shmat");
            exit(1);
    }

    /* read or modify the segment, based on the command line: */
    if (argc == 2) {
            printf("writing to segment: \"%s\"\n", argv[1]);
            strncpy(data, argv[1], SHM_SIZE);
            data[SHM_SIZE-1] = '\0';
    } else
            printf("segment contains: \"%s\"\n", data);

    /* detach from the segment: */
    if (shmdt(data) == -1) {
            perror("shmdt");
            exit(1);
    }

    return 0;
}]]></code>

<p>More commonly, a process will attach to the segment and run for a bit
while other programs are changing and reading the shared segment.  It's
neat to watch one process update the segment and see the changes appear
to other processes.  Again, for simplicity, the sample code doesn't do
that, but you can see how the data is shared between independent
processes.</p>

<p>Also, there's no code in here for removing the segment&emdash;be sure
to do that when you're done messing with it.</p>

</sect2>

</sect1> <!-- Shared Memory Segments -->

<!-- ======================================================= -->
<!-- Memory Mapped Files -->
<!-- ======================================================= -->

<sect1 id="mmap">
<title>Memory Mapped Files</title>

<p>There comes a time when you want to read and write to and from files
so that the information is shared between processes.  Think of it this
way: two processes both open the same file and both read and write from
it, thus sharing the information.  The problem is, sometimes it's a pain
to do all those <func>fseek()</func>s and stuff to get around.  Wouldn't
it be easier if you could just map a section of the file to memory, and
get a pointer to it?  Then you could simply use pointer arithmetic to
get (and set) data in the file.</p>

<p>Well, this is exactly what a memory mapped file is.  And it's really
easy to use, too.  A few simple calls, mixed with a few simple rules,
and you're mapping like a mad-person.</p>

<sect2 id="mmmaker">
<title>Mapmaker</title>

<p>Before mapping a file to memory, you need to get a file descriptor
for it by using the <func>open()</func> system call:</p>

<code>int fd;

fd = open("mapdemofile", O_RDWR);</code>

<p>In this example, we've opened the file for read/write access.  You
can open it in whatever mode you want, but it has to match the mode
specified in the <param>prot</param> parameter to the
<func>mmap()</func> call, below.</p>

<p>To memory map a file, you use the <func>mmap()</func> system call,
which is defined as follows:</p>

<code>void *mmap(void *<param>addr</param>, size_t <param>len</param>, int <param>prot</param>,
           int <param>flags</param>, int <param>fildes</param>, off_t <param>off</param>);</code>

<p>What a slew of parameters!  Here they are, one at a time:</p>


<table border="0">
<tr><td width="15%"><param>addr</param></td>
<td width="85%">This is the address we want the file mapped into.  The
best way to use this is to set it to <const>(void *)0</const> and let
the OS choose it for you.  If you tell it to use an address the OS
doesn't like (for instance, if it's not a multiple of the virtual memory
page size), it'll give you an error.</td></tr>

<tr><td><param>len</param></td>
<td>This parameter is the length of the data we want to map into memory.
This can be any length you want.  (Aside: if <param>len</param> not a
multiple of the virtual memory page size, you will get a blocksize that
is rounded up to that size.  The extra bytes will be 0, and any changes
you make to them will not modify the file.)</td></tr>

<tr><td><param>prot</param></td>
<td>The "protection" argument allows you to specify what kind of access
this process has to the memory mapped region.  This can be a bitwise-ORd
mixture of the following values: <const>PROT_READ</const>,
<const>PROT_WRITE</const>, and <const>PROT_EXEC</const>, for read,
write, and execute permissions, respectively.  The value specified here
must be equivalent to or a subset of the modes specified in the <func>open()</func>
system call that is used to get the file descriptor.</td></tr>

<tr><td><param>flags</param></td>
<td>These are just miscellaneous flags that can be set for the system
call.  You'll want to set it to <const>MAP_SHARED</const> if you're
planning to share your changes to the file with other processes, or
<const>MAP_PRIVATE</const> otherwise.  If you set it to the latter, your
process will get a copy of the mapped region, so any changes you make to
it will not be reflected in the original file&emdash;thus, other
processes will not be able to see them.  We won't talk about
<const>MAP_PRIVATE</const> here at all, since it doesn't have much to do
with IPC.</td></tr>

<tr><td><param>fildes</param></td>
<td>This is where you put that file descriptor you opened
earlier.</td></tr>

<tr><td><param>off</param></td>
<td>This is the offset in the file that you want to start mapping from.
A restriction: this <emp>must</emp> be a multiple of the virtual memory
page size.  This page size can be obtained with a call to
<func>getpagesize()</func>.  Note that 32-bit systems may support
files with sizes that cannot be expressed by 32-bit unsigned integers,
so this type is often a 64-bit type on such systems.</td></tr>

</table>

<p>As for return values, as you might have guessed, <func>mmap()</func>
returns <const>MAP_FAILED</const> on error (the value <const>-1</const>
properly cast to be compared), and sets <var>errno</var>.  Otherwise,
it returns a pointer to the start of the mapped data.</p>

<p>Anyway, without any further ado, we'll do a short demo that maps the
second "page" of a file into memory.  First we'll <func>open()</func> it
to get the file descriptor, then we'll use <func>getpagesize()</func> to
get the size of a virtual memory page and use this value for both the
<param>len</param> and the <param>off</param>.  In this way, we'll start
mapping at the second page, and map for one page's length.  (On my Linux
box, the page size is 4K.)</p>

<code>#include &lt;unistd.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/mman.h&gt;

int fd, pagesize;
char *data;

fd = open("foo", O_RDONLY);
pagesize = getpagesize();
data = mmap((void*)0, pagesize, PROT_READ, MAP_SHARED, fd, pagesize);</code>

<p>Once this code stretch has run, you can access the first byte of the
mapped section of file using <var>data[0]</var>.  Notice there's a lot
of type conversion going on here.  For instance, <func>mmap()</func>
returns <type>void*</type>, but we treat it as a <type>char*</type>.</p>

<p>Also notice that we've mapped the file <const>PROT_READ</const> so we
have read-only access.  Any attempt to write to the data
(<nobr><type>data[0] = 'B'</type></nobr>, for example) will cause a
segmentation violation.  Open the file <const>O_RDWR</const> with
<param>prot</param> set to <const>PROT_READ|PROT_WRITE</const> if you
want read-write access to the data.</p>

</sect2>

<sect2 id="mmunmap">
<title>Unmapping the file</title>

<p>There is, of course, a <func>munmap()</func> function to un-memory map a
file:</p>

<code>int munmap(void *<param>addr</param>, size_t <param>len</param>);</code>

<p>This simply unmaps the region pointed to by <param>addr</param>
(returned from <func>mmap()</func>) with length <param>len</param> (same
as the <param>len</param> passed to <func>mmap()</func>).
<func>munmap()</func> returns <const>-1</const> on error and sets the
<tt>errno</tt> variable.</p>

<p>Once you've unmapped a file, any attempts to access the data through
the old pointer will result in a segmentation fault.  You have been
warned!</p>

<p>A final note: the file will automatically unmap if your program
exits, of course.</p>

</sect2>

<sect2 id="mmconcur">
<title>Concurrency, again?!</title>

<p>If you have multiple processes manipulating the data in the same file
concurrently, you could be in for troubles.  You might have to <link
dest="flocking">lock the file</link> or use <link
dest="semaphores">semaphores</link> to regulate access to the file while
a process messes with it.  Look at the <link dest="shmcon">Shared
Memory</link> document for a (very little bit) more concurrency
information.</p>


</sect2>

<sect2 id="mmsamp">
<title>A simple sample</title>

<p>Well, it's code time again.  I've got here a demo program that maps its
own source to memory and prints the byte that's found at whatever offset
you specify on the command line.</p>

<p>The program restricts the offsets you can specify to the range 0
through the file length.  The file length is obtained through a call to
<func>stat()</func> which you might not have seen before.  It returns a
structure full of file info, one field of which is the size in bytes.
Easy enough.</p>

<p>Here is the source for <file><ulink
url="&samplepre;mmapdemo.c">mmapdemo.c</ulink></file>:</p>

<code><![CDATA[#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <errno.h>

int main(int argc, char *argv[])
{
    int fd;
    off_t offset;
    char *data;
    struct stat sbuf;

    if (argc != 2) {
            fprintf(stderr, "usage: mmapdemo offset\n");
            exit(1);
    }

    if ((fd = open("mmapdemo.c", O_RDONLY)) == -1) {
            perror("open");
            exit(1);
    }

    if (stat("mmapdemo.c", &sbuf) == -1) {
            perror("stat");
            exit(1);
    }


    offset = atoi(argv[1]);
    if (offset < 0 || offset > sbuf.st_size-1) {
        fprintf(stderr, "mmapdemo: offset must be in the range 0-%d\n", \
                                                          sbuf.st_size-1);
        exit(1);
    }
	
    data = mmap((caddr_t)0, sbuf.st_size, PROT_READ, MAP_SHARED, fd, 0);
    if (data == MAP_FAILED) {
        perror("mmap");
        exit(1);
    }

    printf("byte at offset %ld is '%c'\n", offset, data[offset]);

    return 0;
}]]></code>

<p>That's all there is to it.  Compile that sucker up and run it with
some command line like:</p>

<screen>$ mmapdemo 30
byte at offset 30 is 'e'</screen>

<p>I'll leave it up to you to write some really cool programs using this
system call.</p>

</sect2>

<sect2 id="mmobs">
<title>Observations on memory mapping</title>

<p>I would be remiss if I didn't point out a few interesting aspects
of using mapped files on Linux.  First, the memory that the operating
system allocates to use as the storage for the mapped file data is
<emp>the same memory</emp> used to perform file buffering operations
when other processes perform <func>read()</func> and <func>write()</func>
operations!  While <func>read()</func>s and <func>write()</func>s
are guaranteed atomic by POSIX up to a certain size, that goes out
the window when some processes bypass the POSIX functions entirely!</p>

<p>Second, because we're bypassing those POSIX functions, we can
read and write the buffer contents without regard to record locking
that might be applied to the file descriptor (as discussed in a
previous section).  Normally, this isn't a big deal&emdash;who's
going to use memory mapped files in one application while using
record locking in another, when both access the same file?  If the
file is documented to require record locking, then all applications
should use it.  That said, there's nothing stopping an application
from using the read and write locking we discussed previously
immediately before updating the memory that belongs to the mapped
file.</p>

<p>Third, because we're bypassing those POSIX functions (do I sound
like a broken record yet?), the system is not capable of providing
meaningful readahead or writebehind strategies.  As of this writing,
Linux kernel versions 4.x and later <emp>do</emp> implement an
algorithm that detects when two adjacent page faults occur within
a memory mapped file, and it performs a minimal amount of readahead
(just two pages, compared to the readahead configurable at the file
system layer, which can be upwards of 256KB).  There is no writebehind
whatsoever, as there's no practical way to detect when adjacent
pages are written to under current hardware configurations.</p>

<p>Last, given all of the above, there are still very compelling
reasons to use memory mapped files.  The primary one being that
such files are, by definition, "persistent storage", meaning
applications do not have to create lengthy <func>load()</func> /
<func>save()</func> functions for their data if they use memory
mapped files.  However, any binary data will be written in a platform
dependent manner (such as endianness) so those files are likely not
portable.</p>
</sect2>

<sect2 id="mmsum">
<title>Summary</title>

<p>Memory mapped files can be very useful, especially on systems that
don't support shared memory segments.  In fact, the two are very similar
in most respects.  (Memory mapped files are committed to disk, too, so
this could even be an advantage, yes?)  With file locking or semaphores,
data in a memory mapped file can easily be shared between multiple
processes.</p>

</sect2>

</sect1> <!-- Memory Mapped Files -->

<!-- ======================================================= -->
<!-- Unix Sockets -->
<!-- ======================================================= -->

<sect1 id="unixsock">
<title>Unix Sockets</title>

<p>Remember <link dest="fifos">FIFOs</link>?  Remember how they can
only send data in one direction, just like <link
dest="pipes">Pipes</link>?  Wouldn't it be grand if you could send
data in both directions like you can with a socket?</p>

<p>Well, hope no longer, because the answer is here: Unix Domain Sockets!
In case you're still wondering what a socket is, well, it's a two-way
communications pipe, which can be used to communicate in a wide variety
of <emp>domains</emp>.  One of the most common domains sockets communicate
over is the Internet, but we won't discuss that here.  We will, however,
be talking about sockets in the Unix domain; that is, sockets that can
be used between processes on the same Unix system.</p>

<p>Unix sockets use many of the same function calls that Internet
sockets do, and I won't be describing all of the calls I use in detail
within this document.  If the description of a certain call is too vague
(or if you just want to learn more about Internet sockets anyway), I
arbitrarily suggest <booktitle><ulink url="&bgneturl;">Beej's Guide to
Network Programming using Internet Sockets</ulink></booktitle>.  I know
the author personally.</p>

<sect2 id="unixsockover">
<title>Overview</title>

<p>Like I said before, Unix sockets are just like two-way FIFOs.
However, all data communication will be taking place through the sockets
interface, instead of through the file interface.  Although Unix sockets
are a special file in the file system (just like FIFOs), you won't be
using <func>open()</func> and <func>read()</func>&emdash;you'll be using
<func>socket()</func>, <func>bind()</func>, <func>recv()</func>,
etc.</p>

<p>When programming with sockets, you'll usually create server and
client programs.  The server will sit listening for incoming connections
from clients and handle them.  This is very similar to the situation
that exists with Internet sockets, but with some fine differences.</p>

<p>For instance, when describing which Unix socket you want to use (that
is, the path to the special file that is the socket), you use a
<nobr><type>struct sockaddr_un</type></nobr>, which has the following
fields:</p>

<code>struct sockaddr_un {
    unsigned short sun_family;  /* AF_UNIX */
    char sun_path[108];
}</code>

<p>This is the structure you will be passing to the <func>bind()</func>
function, which associates a socket descriptor (a file descriptor) with
a certain file (the name for which is in the <var>sun_path</var>
field).</p>

</sect2>

<sect2 id="unixsockserv">
<title>What to do to be a Server</title>

<p>Without going into too much detail, I'll outline the steps a server
program usually has to go through to do it's thing.  While I'm at it,
I'll be trying to implement an "echo server" which just echos back
everything it gets on the socket.</p>

<p>Here are the server steps:</p>

<numlist>
<li><p><b>Call <func>socket()</func>:</b>  A call to
<func>socket()</func> with the proper arguments creates the Unix
socket:</p>

<code>unsigned int s, s2;
struct sockaddr_un remote, local = {
        .sun_family = AF_UNIX,
        // .sun_path = SOCK_PATH,   // Can't do assignment to an array
};
int len;

s = socket(<emp>AF_UNIX</emp>, SOCK_STREAM, 0);</code>

<p>The second argument, <const>SOCK_STREAM</const>, tells
<func>socket()</func> to create a stream socket.  Yes, datagram sockets
(<const>SOCK_DGRAM</const>) are supported in the Unix domain, but I'm
only going to cover stream sockets here.  For the curious, see <ulink
url="&bgneturl;">Beej's Guide to Network Programming</ulink> for a good
description of unconnected datagram sockets that applies perfectly well
to Unix sockets.  The only thing that changes is that you're now using a
<nobr><type>struct sockaddr_<b>un</b></type></nobr> instead of a
<nobr><type>struct sockaddr_<b>in</b></type></nobr>.</p>

<p>One more note: all these calls return <const>-1</const> on error and
set the global variable <var>errno</var> to reflect whatever went wrong.
Be sure to do your error checking.</p>
</li>

<li><p><b>Call <func>bind()</func>:</b>  You got a socket descriptor
from the call to <func>socket()</func>, now you want to bind that to an
address in the Unix domain.  (That address, as I said before, is a
special file on disk.)</p>

<code>strcpy(local.sun_path, "/home/beej/mysocket");
unlink(local.sun_path);
len = strlen(local.sun_path) + sizeof(local.sun_family);
bind(s, (struct sockaddr *)&amp;local, len);</code>

<p>This associates the socket descriptor "<var>s</var>" with the Unix
socket address "<tt>/home/beej/mysocket</tt>".  Notice that we called
<func>unlink()</func> before <func>bind()</func> to remove the socket if
it already exists.  You will get an <tt>EINVAL</tt> error if the file is
already there.</p>
</li>

<li><p><b>Call <func>listen()</func>:</b>  This instructs the socket to
listen for incoming connections from client programs:</p>

<code>listen(s, 5);</code>

<p>The second argument, <const>5</const>, is the number of incoming
connections that can be queued before you call <func>accept()</func>,
below.  If there are this many connections waiting to be accepted,
additional clients will generate the error
<const>ECONNREFUSED</const>.</p>

</li>

<li><p><b>Call <func>accept()</func>:</b>  This will accept a connection
from a client.  This function returns <emp>another socket
descriptor</emp>!  The old descriptor is still listening for new
connections, but this new one is connected to the client:</p>

<code>len = sizeof(remote);
s2 = accept(s, &amp;remote, &amp;len);</code>

<p>When <func>accept()</func> returns, the <var>remote</var> variable
will be filled with the remote side's <nobr><type>struct
sockaddr_un</type></nobr>, and <var>len</var> will be set to its length.
The descriptor <var>s2</var> is connected to the client, and is ready
for <func>send()</func> and <func>recv()</func>, as described in the
<ulink url="&bgneturl;">Network Programming Guide</ulink>.</p>
</li>

<li><p><b>Handle the connection and loop back to
<func>accept()</func>:</b> Usually you'll want to communicate to the
client here (we'll just echo back everything it sends us), close the
connection, then <func>accept()</func> a new one.</p>

<code>while (len = recv(s2, &amp;buf, 100, 0), len > 0)
    send(s2, &amp;buf, len, 0);

/* loop back to accept() from here */</code>

<!-- if <code> is the last element in an <li>, FOP pukes. Why?? -->
<p></p>
</li>

<li><p><b>Close the connection:</b>  You can close the connection either
by calling <tt>close()</tt>, or by calling <ulink
url="&redir;shutdownman"><func>shutdown()</func></ulink>.</p>

</li>

</numlist>

<p>With all that said, here is some source for an echoing server, <ulink
url="&samplepre;echos.c"><file>echos.c</file></ulink>.  All it does is wait for a
connection on a Unix socket (named, in this case, "echo_socket").</p>

<code><![CDATA[#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <string.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/un.h>
#include <unistd.h>

#define SOCK_PATH "echo_socket"

int main(void)
{
    int s, s2, len;
    struct sockaddr_un remote, local = {
            .sun_family = AF_UNIX,
            // .sun_path = SOCK_PATH,   // Can't do assignment to an array
    };
    char str[100];

    if ((s = socket(AF_UNIX, SOCK_STREAM, 0)) == -1) {
            perror("socket");
            exit(1);
    }

    strcpy(local.sun_path, SOCK_PATH);
    unlink(local.sun_path);
    len = strlen(local.sun_path) + sizeof(local.sun_family);
    if (bind(s, (struct sockaddr *)&local, len) == -1) {
            perror("bind");
            exit(1);
    }

    if (listen(s, 5) == -1) {
            perror("listen");
            exit(1);
    }

    for(;;) {
            int done, n;
            printf("Waiting for a connection...\n");
            socklen_t slen = sizeof(remote);
            if ((s2 = accept(s, (struct sockaddr *)&remote, &slen)) == -1) {
                    perror("accept");
                    exit(1);
            }

            printf("Connected.\n");

            done = 0;
            do {
                    n = recv(s2, str, sizeof(str), 0);
                    if (n <= 0) {
                            if (n < 0) perror("recv");
                            done = 1;
                    }

                    if (!done) 
                            if (send(s2, str, n, 0) < 0) {
                                    perror("send");
                                    done = 1;
                            }
            } while (!done);

            close(s2);
    }

    return 0;
}]]></code>

<p>As you can see, all the aforementioned steps are included in this
program: call <func>socket()</func>, call <func>bind()</func>, call
<func>listen()</func>, call <func>accept()</func>, and do some network
<func>send()</func>s and <func>recv()</func>s.</p>

</sect2>

<sect2 id="sockclient">
<title>What to do to be a client</title>

<p>There needs to be a program to talk to the above server, right?
Except with the client, it's a lot easier because you don't have to do
any pesky <func>listen()</func>ing or <func>accept()</func>ing.  Here
are the steps:</p>

<numlist>
<li>Call <func>socket()</func> to get a Unix domain socket to communicate
through.</li>

<li>Set up a <nobr><type>struct sockaddr_un</type></nobr> with the
remote address (where the server is listening) and call
<func>connect()</func> with that as an argument</li>

<li>Assuming no errors, you're connected to the remote side!  Use
<func>send()</func> and <func>recv()</func> to your heart's
content!</li>

</numlist>

<p>How about code to talk to the echo server, above?  No sweat, friends,
here is <ulink
url="&samplepre;echoc.c"><file>echoc.c</file></ulink>:</p>

<code><![CDATA[#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <string.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/un.h>
#include <unistd.h>

#define SOCK_PATH "echo_socket"

int main(void)
{
    int s, len;
    struct sockaddr_un remote = {
        .sun_family = AF_UNIX,
        // .sun_path = SOCK_PATH,   // Can't do assignment to an array
    };
    char str[100];

    if ((s = socket(AF_UNIX, SOCK_STREAM, 0)) == -1) {
        perror("socket");
        exit(1);
    }

    printf("Trying to connect...\n");

    strcpy(remote.sun_path, SOCK_PATH);
    len = strlen(remote.sun_path) + sizeof(remote.sun_family);
    if (connect(s, (struct sockaddr *)&remote, len) == -1) {
        perror("connect");
        exit(1);
    }

    printf("Connected.\n");

    /* size in fgets() includes the null byte */
    while(printf("> "), fgets(str, sizeof(str), stdin), !feof(stdin)) {
        if (send(s, str, strlen(str)+1, 0) == -1) {
            perror("send");
            exit(1);
        }

        if ((len=recv(s, str, sizeof(str)-1, 0)) > 0) {
            str[len] = '\0';
            printf("echo> %s", str);
        } else {
            if (len < 0) perror("recv");
            else printf("Server closed connection\n");
            exit(1);
        }
    }

    close(s);

    return 0;
}]]></code>

<p>In the client code, of course you'll notice that there are only a few
system calls used to set things up: <func>socket()</func> and
<func>connect()</func>.  Since the client isn't going to be
<func>accept()</func>ing any incoming connections, there's no need for
it to <func>listen()</func>.  Of course, the client still uses
<func>send()</func> and <func>recv()</func> for transferring data.  That
about sums it up.</p>

</sect2>

<sect2 id="socketpair">
<title><tt>socketpair()</tt>&emdash;quick full-duplex pipes</title>

<p>What if you wanted a <link dest="pipes"><func>pipe()</func></link>,
but you wanted to use a single pipe to send and recieve data from
<emp>both sides</emp>?  Since pipes are unidirectional (with exceptions
in SYSV), you can't do it!  There is a solution, though: use a Unix
domain socket, since they can handle bi-directional data.</p>

<p>What a pain, though!  Setting up all that code with
<func>listen()</func> and <func>connect()</func> and all that just to
pass data both ways!  But guess what!  You don't have to!</p>

<p>That's right, there's a beauty of a system call known as
<func>socketpair()</func> this is nice enough to return to you a pair of
<emp>already connected sockets</emp>!  No extra work is needed on your
part; you can immediately use these socket descriptors for interprocess
communication.</p>

<p>For instance, lets set up two processes.  The first sends a
<type>char</type> to the second, and the second changes the character to
uppercase and returns it.  Here is some simple code to do just that,
called <file><ulink url="&samplepre;spair.c">spair.c</ulink></file>
(with no error checking for clarity):</p>

<code><![CDATA[#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <errno.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>

int main(void)
{
    int sv[2]; /* the pair of socket descriptors */
    char buf; /* for data exchange between processes */

    if (socketpair(AF_UNIX, SOCK_STREAM, 0, sv) == -1) {
            perror("socketpair");
            exit(1);
    }

    if (!fork()) {  /* child */
            read(sv[1], &buf, 1);
            printf("child: read '%c'\n", buf);
            buf = toupper(buf);  /* make it uppercase */
            write(sv[1], &buf, 1);
            printf("child: sent '%c'\n", buf);

    } else { /* parent */
            write(sv[0], "b", 1);
            printf("parent: sent 'b'\n");
            read(sv[0], &buf, 1);
            printf("parent: read '%c'\n", buf);
            wait(NULL); /* wait for child to die */
    }

    return 0;
}]]></code>

<p>Sure, it's an expensive way to change a character to uppercase, but
it's the fact that you have simple communication going on here that
really matters.</p>

<p>One more thing to notice is that <func>socketpair()</func> takes both
a domain (<const>AF_UNIX</const>) and socket type
(<const>SOCK_STREAM</const>).  These can be any legal values at all,
depending on which routines in the kernel you want to handle your code,
and whether you want stream or datagram sockets.  I chose
<const>AF_UNIX</const> sockets because this is a Unix sockets document
and they're a bit faster than <const>AF_INET</const> sockets, I
hear.</p>

<p>Finally, you might be curious as to why I'm using
<func>write()</func> and <func>read()</func> instead of
<func>send()</func> and <func>recv()</func>.  Well, in short, I was
being lazy.  See, by using these system calls, I don't have to enter the
<param>flags</param> argument that <func>send()</func> and
<func>recv()</func> use, and I always set it to zero anyway.  Of course,
socket descriptors are just file descriptors like any other, so they
respond just fine to many file manipulation system calls.</p>

</sect2>

</sect1> <!-- Unix Sockets -->

<!-- ======================================================= -->
<!-- References -->
<!-- ======================================================= -->

<sect1 id="references">
<title>More IPC Resources</title>

<sect2 id="refbooks">
<title>Books</title>

<p>Here are some books that describe some of the procedures I've
discussed in this guide, as well as Unix details in specific:</p>

<referenceset>

<reference><title>Unix Network Programming, volumes 1-2</title> by W.
Richard Stevens.  Published by Prentice Hall.  ISBNs for volumes 1-2:
<ulink url="&redir;unixnet1">0131411551</ulink>,
<ulink url="&redir;unixnet2">0130810819</ulink>.
</reference>

<reference><title>Advanced Programming in the UNIX
Environment</title> by W. Richard Stevens.  Published by Addison
Wesley.  ISBN
<ulink url="&redir;advunix">0201433079</ulink>.
</reference>

<reference>Bach, Maurice J.  <title>The Design of the UNIX Operating
System</title>.  New Jersey: Prentice-Hall, 1986.  ISBN <ulink
url="&redir;unixdesign">0132017997</ulink>.</reference>

</referenceset>

</sect2>

<sect2 id="onlineref">
<title>Other online documentation</title>

<referenceset>

<reference><title><ulink url="&unpurl;">UNIX Network Programming Volume
2 home page</ulink></title>&emdash;includes source code from Stevens'
superfine book</reference>

<reference><title><ulink url="&lpgipc;">The Linux Programmer's
Guide</ulink></title>&emdash;in-depth section on IPC</reference>

<reference><title><ulink url="&davesysurl;">UNIX System Calls and
Subroutines using C</ulink></title>&emdash;contains modest IPC
information</reference>

<reference><title><ulink url="&linuxkernelipc;">The Linux
Kernel</ulink></title>&emdash;how the Linux kernel implements
IPC</reference>

</referenceset>

</sect2>

<!-- ======================================================= -->
<!-- Linux man pages -->
<!-- ======================================================= -->

<sect2 id="manpages">
<title>Linux man pages</title>

<p>There are Linux manual pages.  If you run another flavor of Unix,
please look at your own man pages, as these might not work on your
system.</p>

<p><ulink url="&manpre;2/accept.2&manpost;"><func>accept()</func></ulink>,
<ulink url="&manpre;2/bind.2&manpost;"><func>bind()</func></ulink>,
<ulink url="&manpre;2/connect.2&manpost;"><func>connect()</func></ulink>,
<ulink url="&manpre;2/dup.2&manpost;"><func>dup()</func></ulink>,
<ulink url="&manpre;2/exec.2&manpost;"><func>exec()</func></ulink>,
<ulink url="&manpre;2/exit.2&manpost;"><func>exit()</func></ulink>,
<ulink url="&manpre;2/fcntl.2&manpost;"><func>fcntl()</func></ulink>,
<ulink url="&manpre;3/fileno.3&manpost;"><func>fileno()</func></ulink>,
<ulink url="&manpre;2/fork.2&manpost;"><func>fork()</func></ulink>,
<ulink url="&manpre;3/ftok.3&manpost;"><func>ftok()</func></ulink>,
<ulink url="&manpre;2/getpagesize.2&manpost;"><func>getpagesize()</func></ulink>,
<ulink url="&manpre;8/ipcrm.8&manpost;"><com>ipcrm</com></ulink>,
<ulink url="&manpre;8/ipcs.8&manpost;"><com>ipcs</com></ulink>,
<ulink url="&manpre;1/kill.1&manpost;"><com>kill</com></ulink>,
<ulink url="&manpre;2/kill.2&manpost;"><func>kill()</func></ulink>,
<ulink url="&manpre;2/listen.2&manpost;"><func>listen()</func></ulink>,
<ulink url="&manpre;2/lockf.2&manpost;"><func>lockf()</func></ulink>,
<ulink url="&manpre;2/lseek.2&manpost;"><func>lseek()</func></ulink> (for the <var>l_whence</var> field in <nobr><type>struct flock</type></nobr>),
<ulink url="&manpre;1/mknod.1&manpost;"><com>mknod</com></ulink>,
<ulink url="&manpre;2/mknod.2&manpost;"><func>mknod()</func></ulink>,
<ulink url="&manpre;2/mmap.2&manpost;"><func>mmap()</func></ulink>,
<ulink url="&manpre;2/msgctl.2&manpost;"><func>msgctl()</func></ulink>,
<ulink url="&manpre;2/msgget.2&manpost;"><func>msgget()</func></ulink>,
<ulink url="&manpre;2/msgsnd.2&manpost;"><func>msgsnd()</func></ulink>,
<ulink url="&manpre;2/munmap.2&manpost;"><func>munmap()</func></ulink>,
<ulink url="&manpre;2/open.2&manpost;"><func>open()</func></ulink>,
<ulink url="&manpre;2/pipe.2&manpost;"><func>pipe()</func></ulink>,
<ulink url="&manpre;1/ps.1&manpost;"><com>ps</com></ulink>,
<ulink url="&manpre;3/raise.3&manpost;"><func>raise()</func></ulink>,
<ulink url="&manpre;2/read.2&manpost;"><func>read()</func></ulink>,
<ulink url="&manpre;2/recv.2&manpost;"><func>recv()</func></ulink>,
<ulink url="&manpre;2/semctl.2&manpost;"><func>semctl()</func></ulink>,
<ulink url="&manpre;2/semget.2&manpost;"><func>semget()</func></ulink>,
<ulink url="&manpre;2/semop.2&manpost;"><func>semop()</func></ulink>,
<ulink url="&manpre;2/send.2&manpost;"><func>send()</func></ulink>,
<ulink url="&manpre;2/shmat.2&manpost;"><func>shmat()</func></ulink>,
<ulink url="&manpre;2/shmctl.2&manpost;"><func>shmctl()</func></ulink>,
<ulink url="&manpre;2/shmdt.2&manpost;"><func>shmdt()</func></ulink>,
<ulink url="&manpre;2/shmget.2&manpost;"><func>shmget()</func></ulink>,
<ulink url="&manpre;2/sigaction.2&manpost;"><func>sigaction()</func></ulink>,
<ulink url="&manpre;2/signal.2&manpost;"><func>signal()</func></ulink>,
<ulink url="&manpre;7/signal.7&manpost;">signals</ulink>,
<ulink url="&manpre;2/sigpending.2&manpost;"><func>sigpending()</func></ulink>,
<ulink url="&manpre;2/sigprocmask.2&manpost;"><func>sigprocmask()</func></ulink>,
<ulink url="&manpre;2/sigsetops.2&manpost;">sigsetops</ulink>,
<ulink url="&manpre;2/sigsuspend.2&manpost;"><func>sigsuspend()</func></ulink>,
<ulink url="&manpre;2/socket.2&manpost;"><func>socket()</func></ulink>,
<ulink url="&manpre;2/socketpair.2&manpost;"><func>socketpair()</func></ulink>,
<ulink url="&manpre;2/stat.2&manpost;"><func>stat()</func></ulink>,
<ulink url="&manpre;2/wait.2&manpost;"><func>wait()</func></ulink>,
<ulink url="&manpre;2/waitpid.2&manpost;"><func>waitpid()</func></ulink>,
<ulink url="&manpre;2/write.2&manpost;"><func>write()</func></ulink>.</p>

</sect2>

</sect1> <!-- References -->

</guide>

